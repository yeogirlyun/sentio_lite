#!/usr/bin/env python3
"""
Kafka sidecar producer for Sentio Lite (SIGOR v2.0)

Publishes minute-by-minute:
 - Prices per symbol (sentio.prices.minute.v1)
 - Positions state (sentio.positions.state.v1, compacted)
 - Portfolio metrics (sentio.portfolio.minute.v1, compacted)
 - Trades as they occur (sentio.trades.executed.v1)

Modes:
- replay: Reads from results.json (embedded filtered price_data) + trades.jsonl and replays a day.
- polygon: Streams live minute bars from Polygon and publishes price + heartbeat (engine live wiring to follow).

Environment variables (or CLI flags):
 - KAFKA_BOOTSTRAP_SERVERS
 - TOPIC_PREFIX (default: sentio.)
 - REPLAY_SPEED_MS (default: 60) â†’ 1 market minute per 60ms
 - RESULTS_PATH (default: results.json)
 - TRADES_PATH (default: trades.jsonl)
 - STRATEGY (default: SIGOR)
 - ENV (default: MOCK)
 - RUN_ID (default: autogenerated UUID4)

Note: Signal messages are intentionally omitted in v1 to avoid
duplicating strategy internals. They can be added once the engine
exposes per-bar signals in results.json.
"""

import argparse
import json
import os
import time
import uuid
from datetime import datetime, timezone
from typing import Dict, List, Any

from confluent_kafka import Producer

try:
    from polygon import WebSocketClient
    from polygon.websocket.models import WebSocketMessage
except Exception:
    WebSocketClient = None  # Lazy optional import for replay users


def iso_et_from_ms(ms: int) -> str:
    # Convert epoch milliseconds (assumed UTC) to ET ISO string without tz db
    # For development: show offset-less local-style string; app will treat as ET.
    dt = datetime.fromtimestamp(ms / 1000, tz=timezone.utc)
    # Render as naive ET-like string (apps can display as local ET)
    return dt.strftime("%Y-%m-%dT%H:%M:00Z")


def load_results(path: str) -> Dict[str, Any]:
    with open(path, "r") as f:
        return json.load(f)


def load_trades_jsonl(path: str) -> List[Dict[str, Any]]:
    trades: List[Dict[str, Any]] = []
    if not os.path.exists(path):
        return trades
    with open(path, "r") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            trades.append(json.loads(line))
    trades.sort(key=lambda t: t.get("timestamp_ms", 0))
    return trades


def build_kafka_producer(bootstrap: str) -> Producer:
    conf = {"bootstrap.servers": bootstrap, "linger.ms": 5, "batch.num.messages": 1000}
    return Producer(conf)


def publish(producer: Producer, topic: str, key: str, value: Dict[str, Any], headers: Dict[str, str]):
    headers_list = [(k, v.encode("utf-8")) for k, v in headers.items()]
    producer.produce(topic, key=key.encode("utf-8"), value=json.dumps(value).encode("utf-8"), headers=headers_list)


def main():
    parser = argparse.ArgumentParser(description="Sentio Lite Kafka sidecar producer")
    parser.add_argument("--bootstrap", default=os.getenv("KAFKA_BOOTSTRAP_SERVERS", "localhost:9092"))
    parser.add_argument("--prefix", default=os.getenv("TOPIC_PREFIX", "sentio."))
    parser.add_argument("--results", default=os.getenv("RESULTS_PATH", "results.json"))
    parser.add_argument("--trades", default=os.getenv("TRADES_PATH", "trades.jsonl"))
    parser.add_argument("--speed-ms", type=int, default=int(os.getenv("REPLAY_SPEED_MS", "60")))
    parser.add_argument("--strategy", default=os.getenv("STRATEGY", "SIGOR"))
    parser.add_argument("--env", dest="env_name", default=os.getenv("ENV", "MOCK"))
    parser.add_argument("--run-id", default=os.getenv("RUN_ID", str(uuid.uuid4())))
    parser.add_argument("--mode", choices=["replay", "polygon"], default=os.getenv("PRODUCER_MODE", "replay"))
    parser.add_argument("--polygon-key", default=os.getenv("POLYGON_API_KEY", ""))
    parser.add_argument("--symbols", default=os.getenv("SYMBOLS", "TQQQ,SQQQ,TNA,TZA,UVXY,SVIX,SOXS,SOXL,SPXL,SPXS,FAS,FAZ"))
    args = parser.parse_args()
    if args.mode == "replay":
        results = load_results(args.results)
        trades = load_trades_jsonl(args.trades)

        # Extract symbols and price data
        symbols_str = results.get("metadata", {}).get("symbols", "")
        symbols = [s.strip() for s in symbols_str.split(",") if s.strip()]
        price_data: Dict[str, List[Dict[str, Any]]] = results.get("price_data", {})

        # Build a minute timeline
        timeline_ms: List[int] = []
        if symbols:
            ref = symbols[0]
            for bar in price_data.get(ref, []):
                ts = bar.get("timestamp_ms") or bar.get("timestamp")
                if isinstance(ts, str) and ts.isdigit():
                    ts = int(ts)
                if isinstance(ts, (int, float)):
                    minute_ms = int(ts // 60000 * 60000)
                    timeline_ms.append(minute_ms)
        timeline_ms = sorted(list(dict.fromkeys(timeline_ms)))

        producer = build_kafka_producer(args.bootstrap)
        headers = {"strategy": args.strategy, "env": args.env_name, "runId": args.run_id, "version": "v1"}

        trades_by_minute: Dict[int, List[Dict[str, Any]]] = {}
        for t in trades:
            ts = t.get("timestamp_ms", 0)
            minute = int(ts // 60000 * 60000)
            trades_by_minute.setdefault(minute, []).append(t)

        positions: Dict[str, Dict[str, Any]] = {}
        cash = results.get("config", {}).get("initial_capital", 100000.0)

        price_lookup: Dict[str, Dict[int, Dict[str, Any]]] = {}
        for sym in symbols:
            bucketed: Dict[int, Dict[str, Any]] = {}
            for bar in price_data.get(sym, []):
                ts = bar.get("timestamp_ms") or bar.get("timestamp")
                if isinstance(ts, str) and ts.isdigit():
                    ts = int(ts)
                if not isinstance(ts, (int, float)):
                    continue
                minute = int(ts // 60000 * 60000)
                bucketed[minute] = bar
            price_lookup[sym] = bucketed

        prices_topic = f"{args.prefix}prices.minute.v1"
        trades_topic = f"{args.prefix}trades.executed.v1"
        pos_topic = f"{args.prefix}positions.state.v1"
        port_topic = f"{args.prefix}portfolio.minute.v1"
        hb_topic = f"{args.prefix}heartbeat.v1"

        for minute in timeline_ms:
            ts_iso = iso_et_from_ms(minute)

            for sym in symbols:
                bar = price_lookup.get(sym, {}).get(minute)
                if not bar:
                    continue
                payload = {
                    "symbol": sym,
                    "tsET": ts_iso,
                    "open": bar.get("open"),
                    "high": bar.get("high"),
                    "low": bar.get("low"),
                    "close": bar.get("close"),
                    "volume": bar.get("volume")
                }
                publish(producer, prices_topic, sym, payload, {**headers, "timestampET": ts_iso})

            for t in trades_by_minute.get(minute, []):
                sym = t.get("symbol")
                action = t.get("action")
                price = float(t.get("price", 0))
                shares = int(t.get("shares", 0))
                value = float(t.get("value", price * shares))
                pnl = float(t.get("pnl", 0))
                pnl_pct = float(t.get("pnl_pct", 0)) / (100.0 if abs(t.get("pnl_pct", 0)) > 2 else 1)
                reason = t.get("reason", "")

                pub = {
                    "tradeId": str(uuid.uuid4()),
                    "symbol": sym,
                    "action": "BUY" if action == "ENTRY" else "SELL",
                    "tsET": ts_iso,
                    "price": price,
                    "shares": shares,
                    "value": value,
                    "barsHeld": t.get("bars_held", 0),
                    "pnl": pnl,
                    "pnlPct": pnl_pct,
                    "reason": reason
                }
                publish(producer, trades_topic, sym, pub, {**headers, "timestampET": ts_iso})

                pos = positions.get(sym, {"shares": 0, "entryPrice": 0.0})
                if action == "ENTRY":
                    cash -= value
                    total_cost = pos.get("entryPrice", 0.0) * pos.get("shares", 0) + value
                    total_shares = pos.get("shares", 0) + shares
                    pos["entryPrice"] = total_cost / max(1, total_shares)
                    pos["shares"] = total_shares
                    positions[sym] = pos
                else:
                    cash += value + pnl
                    pos_shares = max(0, pos.get("shares", 0) - shares)
                    pos["shares"] = pos_shares
                    if pos_shares == 0:
                        pos["entryPrice"] = 0.0
                    positions[sym] = pos

            total_equity = cash
            for sym, pos in positions.items():
                shares = pos.get("shares", 0)
                if shares <= 0:
                    continue
                bar = price_lookup.get(sym, {}).get(minute)
                if not bar:
                    continue
                mpx = float(bar.get("close", 0))
                entry = float(pos.get("entryPrice", 0))
                unreal = (mpx - entry) * shares if entry > 0 else 0.0
                unreal_pct = ((mpx - entry) / entry) if entry > 0 else 0.0
                total_equity += mpx * shares

                pos_msg = {
                    "symbol": sym,
                    "tsET": ts_iso,
                    "hasPosition": True,
                    "shares": shares,
                    "entryPrice": entry,
                    "marketPrice": mpx,
                    "unrealizedPnl": unreal,
                    "unrealizedPnlPct": unreal_pct
                }
                publish(producer, pos_topic, sym, pos_msg, {**headers, "timestampET": ts_iso})

            initial_capital = float(results.get("config", {}).get("initial_capital", 100000.0))
            port = {
                "portfolioId": "default",
                "tsET": ts_iso,
                "initialCapital": initial_capital,
                "equity": total_equity,
                "cash": cash,
                "totalPnl": total_equity - initial_capital,
                "totalPnlPct": (total_equity - initial_capital) / max(1.0, initial_capital),
                "positions": sum(1 for p in positions.values() if p.get("shares", 0) > 0),
                "tradesToday": sum(len(v) for v in trades_by_minute.values())
            }
            publish(producer, port_topic, "default", port, {**headers, "timestampET": ts_iso})

            hb = {"runId": args.run_id, "tsET": ts_iso, "status": "ok"}
            publish(producer, hb_topic, args.run_id, hb, {**headers, "timestampET": ts_iso})

            producer.flush()
            time.sleep(max(0, args.speed_ms) / 1000.0)
        return

    # polygon mode
    if args.mode == "polygon":
        if WebSocketClient is None:
            raise SystemExit("polygon package not installed. Run: pip install polygon-api-client")

        symbols = [s.strip().upper() for s in args.symbols.split(",") if s.strip()]
        prices_topic = f"{args.prefix}prices.minute.v1"
        hb_topic = f"{args.prefix}heartbeat.v1"
        headers = {"strategy": args.strategy, "env": args.env_name, "runId": args.run_id, "version": "v1"}
        producer = build_kafka_producer(args.bootstrap)

        # Polygon aggregates (per-minute) via WebSocket v3
        subs = [f"A.{sym}" for sym in symbols]

        def handle_msg(msg: WebSocketMessage):
            try:
                for ev in msg.events:
                    if ev.event_type != "A":
                        continue
                    sym = ev.symbol
                    ts_ms = int(ev.start_timestamp)
                    ts_iso = iso_et_from_ms(ts_ms)
                    payload = {
                        "symbol": sym,
                        "tsET": ts_iso,
                        "open": ev.open,
                        "high": ev.high,
                        "low": ev.low,
                        "close": ev.close,
                        "volume": ev.volume
                    }
                    publish(producer, prices_topic, sym, payload, {**headers, "timestampET": ts_iso})
                    hb = {"runId": args.run_id, "tsET": ts_iso, "status": "ok"}
                    publish(producer, hb_topic, args.run_id, hb, {**headers, "timestampET": ts_iso})
                producer.flush()
            except Exception:
                # Swallow and continue (sidecar should be resilient)
                pass

        ws = WebSocketClient(api_key=args.polygon_key, subscriptions=subs, market="stocks", feed="socket")
        ws.run(handle_msg)
        return


if __name__ == "__main__":
    main()


