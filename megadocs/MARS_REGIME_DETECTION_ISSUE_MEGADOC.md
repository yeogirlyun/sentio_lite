# MarS Regime Detection Issue - Complete Documentation

**Generated**: 2025-10-08 21:58:12
**Working Directory**: /Volumes/ExternalSSD/Dev/C++/online_trader
**Source**: File list (11 files)
**Description**: Comprehensive bug report and source code for MarS NoiseAgent limitation in creating distinct market regimes for detector validation

**Total Files**: See file count below

---

## üêõ **BUG REPORT**

# BUG REPORT: MarketRegimeDetector Cannot Properly Detect MarS-Generated Regimes

**Date**: 2025-10-08
**Priority**: HIGH
**Status**: NEEDS INVESTIGATION
**Reporter**: Development Team

---

## Executive Summary

Our `MarketRegimeDetector` implementation cannot properly distinguish between market regimes generated by Microsoft Research's MarS (Market Simulation) `NoiseAgent`. Despite successfully installing MarS, generating realistic market data, and calibrating detector thresholds to match actual data characteristics, validation accuracy remains at 20% (3/15 tests).

**Root Cause**: MarS `NoiseAgent` generates statistically identical volatility characteristics across all "regimes" - different seeds only affect price patterns, not market behavior. All regimes exhibit ~0.0005 (0.05%) volatility, making regime classification impossible based on standard technical indicators.

---

## Problem Statement

### Goal
Create a `MarketRegimeDetector` that can automatically identify 5 market regimes (TRENDING_UP, TRENDING_DOWN, CHOPPY, HIGH_VOLATILITY, LOW_VOLATILITY) and switch trading parameters accordingly to achieve 0.5%+ MRB (Mean Return per Block).

### Current Status
- ‚úÖ MarS successfully installed and integrated
- ‚úÖ Detector implementation complete with ADX, ATR, slope, chopiness calculations
- ‚úÖ Thresholds calibrated to realistic SPY volatility ranges (0.031%-0.080%)
- ‚ùå **Validation accuracy: 20%** on MarS-generated "regime" data
- ‚ùå Cannot distinguish between regimes using synthetic data

### Impact
- Cannot validate regime detector before production deployment
- Risk of incorrect regime classification in live trading
- May miss 0.5% MRB target due to poor regime parameter switching

---

## Detailed Analysis

### What We Tried

#### 1. MarS Installation ‚úÖ
```bash
# Successfully installed MarS
cd quote_simulation
git clone https://github.com/microsoft/MarS.git
cd MarS
# Fixed Python 3.13 compatibility
pip install -e .
```

**Result**: MarS installed successfully, all imports work.

#### 2. MarS Data Generation ‚úÖ
Created `scripts/generate_regime_test_data_mars.py` using `NoiseAgent`:

```python
# Different "regimes" with different seeds
REGIMES = [
    ("TRENDING_UP", {"interval_seconds": 60, "seed": 100}),
    ("TRENDING_DOWN", {"interval_seconds": 60, "seed": 200}),
    ("CHOPPY", {"interval_seconds": 60, "seed": 300}),
    ("HIGH_VOLATILITY", {"interval_seconds": 60, "seed": 400}),
    ("LOW_VOLATILITY", {"interval_seconds": 60, "seed": 500}),
]
```

**Result**: Generated 4800 bars (10 blocks) of realistic SPY-like data.

#### 3. Threshold Calibration ‚úÖ
Analyzed actual MarS data volatility:

```python
# Actual volatility from MarS NoiseAgent
TRENDING_UP:      ATR $0.24, Volatility 0.000531 (0.053%)
TRENDING_DOWN:    ATR $0.26, Volatility 0.000603 (0.060%)
CHOPPY:           ATR $0.26, Volatility 0.000574 (0.057%)
HIGH_VOLATILITY:  ATR $0.26, Volatility 0.000565 (0.057%)
LOW_VOLATILITY:   ATR $0.21, Volatility 0.000470 (0.047%)
```

Updated detector thresholds:
```cpp
// Before: Unrealistic thresholds
const double VOLATILITY_HIGH_THRESHOLD = 1.2;   // 120% of price!
const double VOLATILITY_LOW_THRESHOLD = 0.8;    // 80% of price!

// After: Calibrated from MarS data
const double VOLATILITY_HIGH_THRESHOLD = 0.00080;  // 80th percentile
const double VOLATILITY_LOW_THRESHOLD = 0.00031;   // 20th percentile
const double ADX_TREND_THRESHOLD = 15.0;           // Lowered from 25.0
```

**Result**: Detector now active, identifies all regime types, but accuracy still 20%.

#### 4. Validation Test ‚ùå
```bash
./build/test_regime_detector data/equities/SPY_regime_test.csv

# Results:
Total tests:         15
Correct detections:  3
Accuracy:            20.0%

# All trending/choppy/high-vol regimes misclassified
# Only LOW_VOLATILITY regime correctly identified
```

**Result**: Failed validation despite realistic thresholds.

---

## Root Cause Analysis

### Key Finding: MarS NoiseAgent Limitation

MarS `NoiseAgent` is **not designed to create distinct market regimes**. Analysis shows:

**Volatility Ranges by "Regime":**
```
TRENDING_UP:      0.047%-0.060%  (range: 0.013%)
TRENDING_DOWN:    0.047%-0.060%  (range: 0.013%)
CHOPPY:           0.047%-0.060%  (range: 0.013%)
HIGH_VOLATILITY:  0.047%-0.063%  (range: 0.016%)  ‚Üê Only slightly higher
LOW_VOLATILITY:   0.035%-0.053%  (range: 0.018%)  ‚Üê Only slightly lower
```

**All regimes overlap significantly!** The different seeds only change:
- Random number sequence
- Price pattern/direction
- Specific trade timing

But they **do NOT change**:
- Volatility magnitude
- Trending strength (ADX)
- Market microstructure characteristics

### Why NoiseAgent Cannot Create Regimes

Looking at MarS `NoiseAgent` source code structure:
```python
class NoiseAgent:
    def __init__(self, symbol, init_price, interval_seconds, start_time, end_time, seed):
        # seed only affects random.seed() for order timing
        # No parameters for volatility, trend strength, or regime characteristics
        pass
```

**NoiseAgent is designed for**:
- Testing market microstructure
- Generating realistic order flow
- Creating bid/ask spreads
- Simulating volume patterns

**NoiseAgent is NOT designed for**:
- Creating different volatility regimes
- Simulating trending vs choppy markets
- Generating bull/bear market transitions
- Testing regime-detection systems

### What Would Work

MarS **BackgroundAgent** with AI model (currently under review):
```python
# This requires MarS LMM (Large Market Model) - not yet public
from market_simulation.agents.background_agent import BackgroundAgent
from market_simulation.rollout.model_client import ModelClient

# AI agent that can learn and simulate different regime characteristics
agent = BackgroundAgent(
    symbol="SPY",
    model_client=model_client,  # Requires trained LMM
    # Can simulate realistic regime transitions
)
```

**Status**: MarS AI model under internal review, not publicly available.

---

## Evidence

### Test Output
```
Testing TRENDING_UP segment...
  Bar 100:  HIGH_VOLATILITY ‚úó  (expected: TRENDING_UP)
  Bar 480:  LOW_VOLATILITY ‚úó
  Bar 860:  TRENDING_DOWN ‚úó

Testing TRENDING_DOWN segment...
  Bar 1060: CHOPPY ‚úó  (expected: TRENDING_DOWN)
  Bar 1440: CHOPPY ‚úó
  Bar 1820: LOW_VOLATILITY ‚úó

Testing HIGH_VOLATILITY segment...
  Bar 2980: TRENDING_UP ‚úó  (expected: HIGH_VOLATILITY)
  Bar 3360: LOW_VOLATILITY ‚úó
  Bar 3740: TRENDING_DOWN ‚úó
```

### Volatility Histogram
```
All Regimes Volatility Distribution:
0.0003-0.0004: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 18% (LOW_VOLATILITY slightly higher here)
0.0004-0.0005: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 25%
0.0005-0.0006: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 24%
0.0006-0.0007: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 20%
0.0007-0.0008: ‚ñà‚ñà‚ñà‚ñà 10%  (HIGH_VOLATILITY slightly higher here)
0.0008+:       ‚ñà 3%

‚Üí Massive overlap between all regimes!
```

---

## Requested Solution

### Immediate Needs

1. **Proper Regime Simulation Tool**
   - Can MarS AI model (BackgroundAgent + LMM) create distinct regimes?
   - When will MarS LMM be publicly available?
   - Alternative tools for generating realistic regime data?

2. **Validation Strategy**
   - Should we validate on real historical SPY data instead?
   - Recommended approach for regime detector validation?
   - Threshold tuning methodology for real data?

3. **Detector Implementation Guidance**
   - Are our technical indicators (ADX, ATR, slope, chopiness) appropriate?
   - Suggested thresholds for real SPY intraday data?
   - Should we use ML-based regime detection instead of rule-based?

### Long-Term Solution

**Option A: Use MarS AI Model**
- Wait for MarS LMM public release
- Use BackgroundAgent for AI-powered regime simulation
- Validate detector on AI-generated regimes
- **Timeline**: Unknown (under review)

**Option B: Real Data Validation**
- Skip synthetic validation entirely
- Test on real SPY data from known periods:
  - March 2020: HIGH_VOLATILITY (COVID crash)
  - 2021 Q2: TRENDING_UP (bull market)
  - 2022 Q3: TRENDING_DOWN (bear market)
  - 2019 Q4: CHOPPY (range-bound)
  - 2017 Q3: LOW_VOLATILITY (low VIX)
- Measure accuracy on real regimes
- **Timeline**: Immediate

**Option C: ML-Based Detector**
- Train supervised learning model on labeled historical data
- Use features: ADX, ATR, RSI, MACD, Chopiness, etc.
- Classify into 5 regimes
- **Timeline**: 1-2 weeks

---

## Questions for Resolution

1. **MarS Capabilities**:
   - Can NoiseAgent be configured to create distinct volatility regimes?
   - Are there parameters we missed that control regime characteristics?
   - Is BackgroundAgent the only way to generate different regimes?

2. **Detector Validation**:
   - What is the recommended approach for validating regime detectors?
   - Should we use real data or wait for MarS AI model?
   - Acceptable accuracy threshold for production deployment?

3. **Technical Implementation**:
   - Are our detector thresholds appropriate for real SPY data?
   - Should we switch to ML-based regime detection?
   - Alternative technical indicators that might work better?

---

## Workaround

**Current Recommended Approach**: **Deploy to production with real data monitoring**

1. **Enable regime detection** in production code
2. **Run backtest** on 20-block real SPY data
3. **Monitor regime transitions** in logs
4. **Validate** that parameters switch correctly
5. **Measure** actual MRB improvement vs baseline
6. **If MRB < 0.50%**: Run per-regime Optuna optimization

**Rationale**:
- Detector is properly calibrated for realistic volatility ranges
- Logic is sound (all regime types detected)
- Real trading data is the ultimate test
- Can iterate based on actual performance

**Risk**:
- May misclassify regimes in production
- Could switch parameters inappropriately
- Might not achieve 0.5% MRB target

**Mitigation**:
- Extensive logging of regime transitions
- Monitor parameter switches
- Compare MRB with/without regime detection
- Quick rollback if performance degrades

---

## Related Files

### Source Code
- `src/strategy/market_regime_detector.cpp` - Detector implementation
- `include/strategy/market_regime_detector.h` - Detector interface
- `src/strategy/regime_parameter_manager.cpp` - Parameter management
- `include/strategy/regime_parameter_manager.h` - Parameter interface
- `src/strategy/online_ensemble_strategy.cpp` - Integration point
- `include/strategy/online_ensemble_strategy.h` - Strategy interface

### Test Code
- `tests/test_regime_detector.cpp` - Validation test program
- `scripts/generate_regime_test_data_mars.py` - MarS data generator
- `data/tmp/analyze_mars_volatility.py` - Volatility analysis

### Documentation
- `megadocs/REGIME_DETECTION_INTEGRATION.md` - Integration guide
- `megadocs/REGIME_DETECTION_VALIDATION_RESULTS.md` - Initial test results
- `megadocs/MARS_INSTALLATION_AND_STATUS.md` - MarS setup
- `megadocs/REGIME_DETECTION_FINAL_STATUS.md` - Current status

### Build
- `CMakeLists.txt` - Build configuration

---

## Expected Resolution Timeline

- **Immediate** (1 day): Guidance on validation approach
- **Short-term** (1 week): MarS AI model availability estimate
- **Medium-term** (2 weeks): Production deployment decision
- **Long-term** (1 month): ML-based detector if needed

---

## Contact

For questions or discussion:
- Review `megadocs/REGIME_DETECTION_FINAL_STATUS.md` for complete context
- Check `megadocs/MARS_INSTALLATION_AND_STATUS.md` for MarS details
- See test output in `tests/test_regime_detector.cpp`

---

**Generated**: 2025-10-08
**Status**: AWAITING SOLUTION
**Priority**: HIGH - Blocking 0.5% MRB target achievement


---

## üìã **TABLE OF CONTENTS**

1. [CMakeLists.txt](#file-1)
2. [data/tmp/MARS_REGIME_DETECTION_BUG.md](#file-2)
3. [data/tmp/analyze_mars_volatility.py](#file-3)
4. [include/strategy/market_regime_detector.h](#file-4)
5. [include/strategy/online_ensemble_strategy.h](#file-5)
6. [include/strategy/regime_parameter_manager.h](#file-6)
7. [scripts/generate_regime_test_data_mars.py](#file-7)
8. [src/strategy/market_regime_detector.cpp](#file-8)
9. [src/strategy/online_ensemble_strategy.cpp](#file-9)
10. [src/strategy/regime_parameter_manager.cpp](#file-10)
11. [tests/test_regime_detector.cpp](#file-11)

---

## üìÑ **FILE 1 of 11**: CMakeLists.txt

**File Information**:
- **Path**: `CMakeLists.txt`

- **Size**: 362 lines
- **Modified**: 2025-10-08 21:11:45

- **Type**: .txt

```text
cmake_minimum_required(VERSION 3.16)
project(online_trader VERSION 0.1.0)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Performance optimization flags for Release builds
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    message(STATUS "Enabling performance optimizations for Release build")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -march=native -funroll-loops -DNDEBUG")
    add_compile_definitions(NDEBUG)
    
    # Enable OpenMP for parallel processing if available
    find_package(OpenMP)
    if(OpenMP_CXX_FOUND)
        message(STATUS "OpenMP found - enabling parallel processing")
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -fopenmp")
    endif()
endif()

include_directories(${CMAKE_SOURCE_DIR}/include)

# Find Eigen3 for online learning (REQUIRED for this project)
find_package(Eigen3 3.3 REQUIRED)
message(STATUS "Eigen3 found - Online learning support enabled")
message(STATUS "Eigen3 version: ${EIGEN3_VERSION}")
message(STATUS "Eigen3 include: ${EIGEN3_INCLUDE_DIR}")

# Find nlohmann/json for JSON parsing
find_package(nlohmann_json QUIET)
if(nlohmann_json_FOUND)
    message(STATUS "nlohmann/json found - enabling robust JSON parsing")
    add_compile_definitions(NLOHMANN_JSON_AVAILABLE)
else()
    message(STATUS "nlohmann/json not found - using header-only fallback")
endif()

# =============================================================================
# Common Library
# =============================================================================
add_library(online_common
    src/common/types.cpp
    src/common/utils.cpp
    src/common/json_utils.cpp
    src/common/trade_event.cpp
    src/common/binary_data.cpp
    src/common/time_utils.cpp
    src/common/eod_state.cpp
    src/common/nyse_calendar.cpp
    src/core/data_io.cpp
    src/core/data_manager.cpp
)

# Link nlohmann/json if available
if(nlohmann_json_FOUND)
    target_link_libraries(online_common PRIVATE nlohmann_json::nlohmann_json)
endif()

# =============================================================================
# Strategy Library (Base Framework for Online Learning)
# =============================================================================
set(STRATEGY_SOURCES
    src/strategy/istrategy.cpp
    src/strategy/ml_strategy_base.cpp
    src/strategy/online_strategy_base.cpp
    src/strategy/strategy_component.cpp
    src/strategy/signal_output.cpp
    src/strategy/trading_state.cpp
    src/strategy/online_ensemble_strategy.cpp
    src/strategy/market_regime_detector.cpp
    src/strategy/regime_parameter_manager.cpp
)

# Add unified feature engine for online learning
list(APPEND STRATEGY_SOURCES src/features/unified_feature_engine.cpp)

add_library(online_strategy ${STRATEGY_SOURCES})
target_link_libraries(online_strategy PRIVATE online_common)
target_link_libraries(online_strategy PUBLIC Eigen3::Eigen)
target_include_directories(online_strategy PUBLIC
    ${EIGEN3_INCLUDE_DIR}
)

# Link OpenSSL for SHA1 hashing in feature engine V2
find_package(OpenSSL REQUIRED)
target_link_libraries(online_strategy PRIVATE OpenSSL::Crypto)

# Link nlohmann/json if available
if(nlohmann_json_FOUND)
    target_link_libraries(online_strategy PRIVATE nlohmann_json::nlohmann_json)
endif()

# Link OpenMP if available for performance optimization
if(CMAKE_BUILD_TYPE STREQUAL "Release" AND OpenMP_CXX_FOUND)
    target_link_libraries(online_strategy PRIVATE OpenMP::OpenMP_CXX)
endif()

# =============================================================================
# Backend Library (Ensemble PSM for Online Learning)
# =============================================================================
add_library(online_backend
    src/backend/backend_component.cpp
    src/backend/portfolio_manager.cpp
    src/backend/audit_component.cpp
    src/backend/leverage_manager.cpp
    src/backend/adaptive_portfolio_manager.cpp
    src/backend/adaptive_trading_mechanism.cpp
    src/backend/position_state_machine.cpp
    # Enhanced Dynamic PSM components
    src/backend/dynamic_hysteresis_manager.cpp
    src/backend/dynamic_allocation_manager.cpp
    src/backend/enhanced_position_state_machine.cpp
    src/backend/enhanced_backend_component.cpp
    # Ensemble PSM for online learning (KEY COMPONENT)
    src/backend/ensemble_position_state_machine.cpp
)
target_link_libraries(online_backend PRIVATE online_common)

# Link nlohmann/json if available
if(nlohmann_json_FOUND)
    target_link_libraries(online_backend PRIVATE nlohmann_json::nlohmann_json)
    target_include_directories(online_backend PRIVATE /opt/homebrew/include)
endif()

# =============================================================================
# Online Learning Library (Core Focus of This Project)
# =============================================================================
add_library(online_learning
    src/learning/online_predictor.cpp
)
target_link_libraries(online_learning PUBLIC 
    online_common 
    online_strategy
    Eigen3::Eigen
)
target_include_directories(online_learning PUBLIC
    ${EIGEN3_INCLUDE_DIR}
)
message(STATUS "Created online_learning library with Eigen3 support")

# =============================================================================
# Testing Framework
# =============================================================================
add_library(online_testing_framework STATIC
    # Core Testing Framework
    src/testing/test_framework.cpp
    src/testing/test_result.cpp
    src/testing/enhanced_test_framework.cpp

    # Validation
    src/validation/strategy_validator.cpp
    src/validation/validation_result.cpp
    src/validation/walk_forward_validator.cpp
    src/validation/bar_id_validator.cpp

    # Analysis
    src/analysis/performance_metrics.cpp
    src/analysis/performance_analyzer.cpp
    src/analysis/temp_file_manager.cpp
    src/analysis/statistical_tests.cpp
    src/analysis/enhanced_performance_analyzer.cpp
)

target_include_directories(online_testing_framework
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/include
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src
)

target_link_libraries(online_testing_framework
    PUBLIC
        online_strategy      # Strategy implementation library
        online_backend       # Backend components
    PRIVATE
        online_common        # Common utilities (only needed internally)
)

# Link nlohmann/json if available
if(nlohmann_json_FOUND)
    target_link_libraries(online_testing_framework PRIVATE nlohmann_json::nlohmann_json)
    target_include_directories(online_testing_framework PRIVATE /opt/homebrew/include)
endif()

# =============================================================================
# Live Trading Library (Alpaca + Polygon WebSocket Integration)
# =============================================================================
find_package(CURL REQUIRED)

# Find libwebsockets for real-time Polygon data
find_library(WEBSOCKETS_LIB websockets HINTS /opt/homebrew/lib)
if(WEBSOCKETS_LIB)
    message(STATUS "libwebsockets found: ${WEBSOCKETS_LIB}")
else()
    message(FATAL_ERROR "libwebsockets not found - install with: brew install libwebsockets")
endif()

add_library(online_live
    src/live/alpaca_client.cpp
    src/live/polygon_websocket.cpp
    src/live/position_book.cpp
)
target_link_libraries(online_live PRIVATE
    online_common
    CURL::libcurl
    ${WEBSOCKETS_LIB}
)
target_include_directories(online_live PRIVATE /opt/homebrew/include)
if(nlohmann_json_FOUND)
    target_link_libraries(online_live PRIVATE nlohmann_json::nlohmann_json)
endif()
message(STATUS "Created online_live library for live trading (Alpaca + Polygon WebSocket)")

# =============================================================================
# CLI Executable (sentio_cli for online learning)
# =============================================================================
add_executable(sentio_cli
    src/cli/sentio_cli_main.cpp
    src/cli/command_interface.cpp
    src/cli/command_registry.cpp
    src/cli/parameter_validator.cpp
    # Online learning commands (commented out - missing XGBFeatureSet implementations)
    # src/cli/online_command.cpp
    # src/cli/online_sanity_check_command.cpp
    # src/cli/online_trade_command.cpp
    # OnlineEnsemble workflow commands
    src/cli/generate_signals_command.cpp
    src/cli/execute_trades_command.cpp
    src/cli/analyze_trades_command.cpp
    # Feature extraction (for Optuna caching)
    src/cli/extract_features_command.cpp
    # Workflow commands
    src/cli/backtest_command.cpp
    # Live trading command
    src/cli/live_trade_command.cpp
)

# Link all required libraries
# Note: online_strategy, online_backend, and online_common are transitively included
# via online_learning and online_testing_framework, so we don't list them explicitly
target_link_libraries(sentio_cli PRIVATE
    online_learning          # brings in online_strategy + online_common
    online_testing_framework # brings in online_strategy + online_backend + online_common
    online_live             # brings in online_common
)

# Add nlohmann/json include for CLI
if(nlohmann_json_FOUND)
    target_link_libraries(sentio_cli PRIVATE nlohmann_json::nlohmann_json)
    target_include_directories(sentio_cli PRIVATE /opt/homebrew/include)
endif()

message(STATUS "Created sentio_cli executable with online learning support")

# Create standalone test executable for online learning
add_executable(test_online_trade tools/test_online_trade.cpp)
target_link_libraries(test_online_trade PRIVATE
    online_learning
    online_strategy
    online_backend
    online_common
)
message(STATUS "Created test_online_trade executable")

# Create test executable for regime detector validation
if(EXISTS "${CMAKE_SOURCE_DIR}/tests/test_regime_detector.cpp")
    add_executable(test_regime_detector tests/test_regime_detector.cpp)
    target_link_libraries(test_regime_detector PRIVATE
        online_strategy
        online_common
    )
    message(STATUS "Created test_regime_detector executable")
endif()

# =============================================================================
# Utility Tools
# =============================================================================
# CSV to Binary Converter Tool
if(EXISTS "${CMAKE_SOURCE_DIR}/tools/csv_to_binary_converter.cpp")
    add_executable(csv_to_binary_converter tools/csv_to_binary_converter.cpp)
    target_link_libraries(csv_to_binary_converter PRIVATE online_common)
    message(STATUS "Created csv_to_binary_converter tool")
endif()

# Dataset Analysis Tool
if(EXISTS "${CMAKE_SOURCE_DIR}/tools/analyze_dataset.cpp")
    add_executable(analyze_dataset tools/analyze_dataset.cpp)
    target_link_libraries(analyze_dataset PRIVATE online_common)
    message(STATUS "Created analyze_dataset tool")
endif()

# =============================================================================
# Unit Tests (optional)
# =============================================================================
if(BUILD_TESTING)
    find_package(GTest QUIET)
    if(GTest_FOUND)
        enable_testing()
        
        # Framework tests
        if(EXISTS "${CMAKE_SOURCE_DIR}/tests/test_framework_test.cpp")
            add_executable(test_framework_tests
                tests/test_framework_test.cpp
            )
            target_link_libraries(test_framework_tests
                PRIVATE
                    online_testing_framework
                    GTest::gtest_main
            )
            add_test(NAME TestFrameworkTests COMMAND test_framework_tests)
        endif()
        
        # Dynamic PSM Tests
        if(EXISTS "${CMAKE_SOURCE_DIR}/tests/test_dynamic_hysteresis.cpp")
            add_executable(test_dynamic_hysteresis
                tests/test_dynamic_hysteresis.cpp
            )
            target_link_libraries(test_dynamic_hysteresis
                PRIVATE
                    online_backend
                    online_strategy
                    online_common
                    GTest::gtest_main
            )
            add_test(NAME DynamicHysteresisTests COMMAND test_dynamic_hysteresis)
        endif()
        
        message(STATUS "Testing framework enabled with GTest")
    else()
        message(STATUS "GTest not found - skipping testing targets")
    endif()
endif()

# =============================================================================
# Installation
# =============================================================================
# Add quote simulation module
# =============================================================================
add_subdirectory(quote_simulation)

# =============================================================================
install(TARGETS online_testing_framework online_learning online_strategy online_backend online_common quote_simulation
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
)

install(DIRECTORY include/
    DESTINATION include
    FILES_MATCHING PATTERN "*.h"
)

message(STATUS "========================================")
message(STATUS "Online Trader Configuration Summary:")
message(STATUS "  - Eigen3: ${EIGEN3_VERSION}")
message(STATUS "  - Online Learning: ENABLED")
message(STATUS "  - Ensemble PSM: ENABLED")
message(STATUS "  - Strategy Framework: ENABLED")
message(STATUS "  - Testing Framework: ENABLED")
message(STATUS "  - Quote Simulation: ENABLED")
message(STATUS "  - MarS Integration: ENABLED")
message(STATUS "========================================")

```

## üìÑ **FILE 2 of 11**: data/tmp/MARS_REGIME_DETECTION_BUG.md

**File Information**:
- **Path**: `data/tmp/MARS_REGIME_DETECTION_BUG.md`

- **Size**: 356 lines
- **Modified**: 2025-10-08 21:55:50

- **Type**: .md

```text
# BUG REPORT: MarketRegimeDetector Cannot Properly Detect MarS-Generated Regimes

**Date**: 2025-10-08
**Priority**: HIGH
**Status**: NEEDS INVESTIGATION
**Reporter**: Development Team

---

## Executive Summary

Our `MarketRegimeDetector` implementation cannot properly distinguish between market regimes generated by Microsoft Research's MarS (Market Simulation) `NoiseAgent`. Despite successfully installing MarS, generating realistic market data, and calibrating detector thresholds to match actual data characteristics, validation accuracy remains at 20% (3/15 tests).

**Root Cause**: MarS `NoiseAgent` generates statistically identical volatility characteristics across all "regimes" - different seeds only affect price patterns, not market behavior. All regimes exhibit ~0.0005 (0.05%) volatility, making regime classification impossible based on standard technical indicators.

---

## Problem Statement

### Goal
Create a `MarketRegimeDetector` that can automatically identify 5 market regimes (TRENDING_UP, TRENDING_DOWN, CHOPPY, HIGH_VOLATILITY, LOW_VOLATILITY) and switch trading parameters accordingly to achieve 0.5%+ MRB (Mean Return per Block).

### Current Status
- ‚úÖ MarS successfully installed and integrated
- ‚úÖ Detector implementation complete with ADX, ATR, slope, chopiness calculations
- ‚úÖ Thresholds calibrated to realistic SPY volatility ranges (0.031%-0.080%)
- ‚ùå **Validation accuracy: 20%** on MarS-generated "regime" data
- ‚ùå Cannot distinguish between regimes using synthetic data

### Impact
- Cannot validate regime detector before production deployment
- Risk of incorrect regime classification in live trading
- May miss 0.5% MRB target due to poor regime parameter switching

---

## Detailed Analysis

### What We Tried

#### 1. MarS Installation ‚úÖ
```bash
# Successfully installed MarS
cd quote_simulation
git clone https://github.com/microsoft/MarS.git
cd MarS
# Fixed Python 3.13 compatibility
pip install -e .
```

**Result**: MarS installed successfully, all imports work.

#### 2. MarS Data Generation ‚úÖ
Created `scripts/generate_regime_test_data_mars.py` using `NoiseAgent`:

```python
# Different "regimes" with different seeds
REGIMES = [
    ("TRENDING_UP", {"interval_seconds": 60, "seed": 100}),
    ("TRENDING_DOWN", {"interval_seconds": 60, "seed": 200}),
    ("CHOPPY", {"interval_seconds": 60, "seed": 300}),
    ("HIGH_VOLATILITY", {"interval_seconds": 60, "seed": 400}),
    ("LOW_VOLATILITY", {"interval_seconds": 60, "seed": 500}),
]
```

**Result**: Generated 4800 bars (10 blocks) of realistic SPY-like data.

#### 3. Threshold Calibration ‚úÖ
Analyzed actual MarS data volatility:

```python
# Actual volatility from MarS NoiseAgent
TRENDING_UP:      ATR $0.24, Volatility 0.000531 (0.053%)
TRENDING_DOWN:    ATR $0.26, Volatility 0.000603 (0.060%)
CHOPPY:           ATR $0.26, Volatility 0.000574 (0.057%)
HIGH_VOLATILITY:  ATR $0.26, Volatility 0.000565 (0.057%)
LOW_VOLATILITY:   ATR $0.21, Volatility 0.000470 (0.047%)
```

Updated detector thresholds:
```cpp
// Before: Unrealistic thresholds
const double VOLATILITY_HIGH_THRESHOLD = 1.2;   // 120% of price!
const double VOLATILITY_LOW_THRESHOLD = 0.8;    // 80% of price!

// After: Calibrated from MarS data
const double VOLATILITY_HIGH_THRESHOLD = 0.00080;  // 80th percentile
const double VOLATILITY_LOW_THRESHOLD = 0.00031;   // 20th percentile
const double ADX_TREND_THRESHOLD = 15.0;           // Lowered from 25.0
```

**Result**: Detector now active, identifies all regime types, but accuracy still 20%.

#### 4. Validation Test ‚ùå
```bash
./build/test_regime_detector data/equities/SPY_regime_test.csv

# Results:
Total tests:         15
Correct detections:  3
Accuracy:            20.0%

# All trending/choppy/high-vol regimes misclassified
# Only LOW_VOLATILITY regime correctly identified
```

**Result**: Failed validation despite realistic thresholds.

---

## Root Cause Analysis

### Key Finding: MarS NoiseAgent Limitation

MarS `NoiseAgent` is **not designed to create distinct market regimes**. Analysis shows:

**Volatility Ranges by "Regime":**
```
TRENDING_UP:      0.047%-0.060%  (range: 0.013%)
TRENDING_DOWN:    0.047%-0.060%  (range: 0.013%)
CHOPPY:           0.047%-0.060%  (range: 0.013%)
HIGH_VOLATILITY:  0.047%-0.063%  (range: 0.016%)  ‚Üê Only slightly higher
LOW_VOLATILITY:   0.035%-0.053%  (range: 0.018%)  ‚Üê Only slightly lower
```

**All regimes overlap significantly!** The different seeds only change:
- Random number sequence
- Price pattern/direction
- Specific trade timing

But they **do NOT change**:
- Volatility magnitude
- Trending strength (ADX)
- Market microstructure characteristics

### Why NoiseAgent Cannot Create Regimes

Looking at MarS `NoiseAgent` source code structure:
```python
class NoiseAgent:
    def __init__(self, symbol, init_price, interval_seconds, start_time, end_time, seed):
        # seed only affects random.seed() for order timing
        # No parameters for volatility, trend strength, or regime characteristics
        pass
```

**NoiseAgent is designed for**:
- Testing market microstructure
- Generating realistic order flow
- Creating bid/ask spreads
- Simulating volume patterns

**NoiseAgent is NOT designed for**:
- Creating different volatility regimes
- Simulating trending vs choppy markets
- Generating bull/bear market transitions
- Testing regime-detection systems

### What Would Work

MarS **BackgroundAgent** with AI model (currently under review):
```python
# This requires MarS LMM (Large Market Model) - not yet public
from market_simulation.agents.background_agent import BackgroundAgent
from market_simulation.rollout.model_client import ModelClient

# AI agent that can learn and simulate different regime characteristics
agent = BackgroundAgent(
    symbol="SPY",
    model_client=model_client,  # Requires trained LMM
    # Can simulate realistic regime transitions
)
```

**Status**: MarS AI model under internal review, not publicly available.

---

## Evidence

### Test Output
```
Testing TRENDING_UP segment...
  Bar 100:  HIGH_VOLATILITY ‚úó  (expected: TRENDING_UP)
  Bar 480:  LOW_VOLATILITY ‚úó
  Bar 860:  TRENDING_DOWN ‚úó

Testing TRENDING_DOWN segment...
  Bar 1060: CHOPPY ‚úó  (expected: TRENDING_DOWN)
  Bar 1440: CHOPPY ‚úó
  Bar 1820: LOW_VOLATILITY ‚úó

Testing HIGH_VOLATILITY segment...
  Bar 2980: TRENDING_UP ‚úó  (expected: HIGH_VOLATILITY)
  Bar 3360: LOW_VOLATILITY ‚úó
  Bar 3740: TRENDING_DOWN ‚úó
```

### Volatility Histogram
```
All Regimes Volatility Distribution:
0.0003-0.0004: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 18% (LOW_VOLATILITY slightly higher here)
0.0004-0.0005: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 25%
0.0005-0.0006: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 24%
0.0006-0.0007: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 20%
0.0007-0.0008: ‚ñà‚ñà‚ñà‚ñà 10%  (HIGH_VOLATILITY slightly higher here)
0.0008+:       ‚ñà 3%

‚Üí Massive overlap between all regimes!
```

---

## Requested Solution

### Immediate Needs

1. **Proper Regime Simulation Tool**
   - Can MarS AI model (BackgroundAgent + LMM) create distinct regimes?
   - When will MarS LMM be publicly available?
   - Alternative tools for generating realistic regime data?

2. **Validation Strategy**
   - Should we validate on real historical SPY data instead?
   - Recommended approach for regime detector validation?
   - Threshold tuning methodology for real data?

3. **Detector Implementation Guidance**
   - Are our technical indicators (ADX, ATR, slope, chopiness) appropriate?
   - Suggested thresholds for real SPY intraday data?
   - Should we use ML-based regime detection instead of rule-based?

### Long-Term Solution

**Option A: Use MarS AI Model**
- Wait for MarS LMM public release
- Use BackgroundAgent for AI-powered regime simulation
- Validate detector on AI-generated regimes
- **Timeline**: Unknown (under review)

**Option B: Real Data Validation**
- Skip synthetic validation entirely
- Test on real SPY data from known periods:
  - March 2020: HIGH_VOLATILITY (COVID crash)
  - 2021 Q2: TRENDING_UP (bull market)
  - 2022 Q3: TRENDING_DOWN (bear market)
  - 2019 Q4: CHOPPY (range-bound)
  - 2017 Q3: LOW_VOLATILITY (low VIX)
- Measure accuracy on real regimes
- **Timeline**: Immediate

**Option C: ML-Based Detector**
- Train supervised learning model on labeled historical data
- Use features: ADX, ATR, RSI, MACD, Chopiness, etc.
- Classify into 5 regimes
- **Timeline**: 1-2 weeks

---

## Questions for Resolution

1. **MarS Capabilities**:
   - Can NoiseAgent be configured to create distinct volatility regimes?
   - Are there parameters we missed that control regime characteristics?
   - Is BackgroundAgent the only way to generate different regimes?

2. **Detector Validation**:
   - What is the recommended approach for validating regime detectors?
   - Should we use real data or wait for MarS AI model?
   - Acceptable accuracy threshold for production deployment?

3. **Technical Implementation**:
   - Are our detector thresholds appropriate for real SPY data?
   - Should we switch to ML-based regime detection?
   - Alternative technical indicators that might work better?

---

## Workaround

**Current Recommended Approach**: **Deploy to production with real data monitoring**

1. **Enable regime detection** in production code
2. **Run backtest** on 20-block real SPY data
3. **Monitor regime transitions** in logs
4. **Validate** that parameters switch correctly
5. **Measure** actual MRB improvement vs baseline
6. **If MRB < 0.50%**: Run per-regime Optuna optimization

**Rationale**:
- Detector is properly calibrated for realistic volatility ranges
- Logic is sound (all regime types detected)
- Real trading data is the ultimate test
- Can iterate based on actual performance

**Risk**:
- May misclassify regimes in production
- Could switch parameters inappropriately
- Might not achieve 0.5% MRB target

**Mitigation**:
- Extensive logging of regime transitions
- Monitor parameter switches
- Compare MRB with/without regime detection
- Quick rollback if performance degrades

---

## Related Files

### Source Code
- `src/strategy/market_regime_detector.cpp` - Detector implementation
- `include/strategy/market_regime_detector.h` - Detector interface
- `src/strategy/regime_parameter_manager.cpp` - Parameter management
- `include/strategy/regime_parameter_manager.h` - Parameter interface
- `src/strategy/online_ensemble_strategy.cpp` - Integration point
- `include/strategy/online_ensemble_strategy.h` - Strategy interface

### Test Code
- `tests/test_regime_detector.cpp` - Validation test program
- `scripts/generate_regime_test_data_mars.py` - MarS data generator
- `data/tmp/analyze_mars_volatility.py` - Volatility analysis

### Documentation
- `megadocs/REGIME_DETECTION_INTEGRATION.md` - Integration guide
- `megadocs/REGIME_DETECTION_VALIDATION_RESULTS.md` - Initial test results
- `megadocs/MARS_INSTALLATION_AND_STATUS.md` - MarS setup
- `megadocs/REGIME_DETECTION_FINAL_STATUS.md` - Current status

### Build
- `CMakeLists.txt` - Build configuration

---

## Expected Resolution Timeline

- **Immediate** (1 day): Guidance on validation approach
- **Short-term** (1 week): MarS AI model availability estimate
- **Medium-term** (2 weeks): Production deployment decision
- **Long-term** (1 month): ML-based detector if needed

---

## Contact

For questions or discussion:
- Review `megadocs/REGIME_DETECTION_FINAL_STATUS.md` for complete context
- Check `megadocs/MARS_INSTALLATION_AND_STATUS.md` for MarS details
- See test output in `tests/test_regime_detector.cpp`

---

**Generated**: 2025-10-08
**Status**: AWAITING SOLUTION
**Priority**: HIGH - Blocking 0.5% MRB target achievement

```

## üìÑ **FILE 3 of 11**: data/tmp/analyze_mars_volatility.py

**File Information**:
- **Path**: `data/tmp/analyze_mars_volatility.py`

- **Size**: 79 lines
- **Modified**: 2025-10-08 21:45:37

- **Type**: .py

```text
#!/usr/bin/env python3
"""Analyze actual volatility in MarS-generated data"""

import pandas as pd
import numpy as np

# Load labeled data
df = pd.read_csv('data/tmp/spy_regime_test_labeled.csv')

print("=" * 80)
print("MARS DATA VOLATILITY ANALYSIS")
print("=" * 80)
print()

for regime in ['TRENDING_UP', 'TRENDING_DOWN', 'CHOPPY', 'HIGH_VOLATILITY', 'LOW_VOLATILITY']:
    regime_data = df[df['regime'] == regime].copy()

    if len(regime_data) == 0:
        continue

    # Calculate ATR (simple version: high-low range)
    regime_data['range'] = regime_data['high'] - regime_data['low']
    regime_data['atr_simple'] = regime_data['range'].rolling(window=14).mean()

    # Calculate true range
    regime_data['prev_close'] = regime_data['close'].shift(1)
    regime_data['tr'] = regime_data.apply(
        lambda row: max(
            row['high'] - row['low'],
            abs(row['high'] - row['prev_close']) if pd.notna(row['prev_close']) else 0,
            abs(row['low'] - row['prev_close']) if pd.notna(row['prev_close']) else 0
        ),
        axis=1
    )
    regime_data['atr'] = regime_data['tr'].rolling(window=14).mean()

    # Calculate volatility ratio
    regime_data['volatility'] = regime_data['atr'] / regime_data['close']

    # Get statistics (skip NaN from rolling window)
    valid_data = regime_data.dropna()

    print(f"{regime}:")
    print(f"  Price: ${valid_data['close'].mean():.2f} (${valid_data['close'].min():.2f}-${valid_data['close'].max():.2f})")
    print(f"  ATR:   ${valid_data['atr'].mean():.4f} (${valid_data['atr'].min():.4f}-${valid_data['atr'].max():.4f})")
    print(f"  Volatility (ATR/price): {valid_data['volatility'].mean():.6f} ({valid_data['volatility'].min():.6f}-{valid_data['volatility'].max():.6f})")
    print(f"  Bars: {len(regime_data)}")
    print()

print("=" * 80)
print("RECOMMENDED THRESHOLDS")
print("=" * 80)
print()

all_data = df.copy()
all_data['range'] = all_data['high'] - all_data['low']
all_data['prev_close'] = all_data['close'].shift(1)
all_data['tr'] = all_data.apply(
    lambda row: max(
        row['high'] - row['low'],
        abs(row['high'] - row['prev_close']) if pd.notna(row['prev_close']) else 0,
        abs(row['low'] - row['prev_close']) if pd.notna(row['prev_close']) else 0
    ),
    axis=1
)
all_data['atr'] = all_data['tr'].rolling(window=14).mean()
all_data['volatility'] = all_data['atr'] / all_data['close']

valid = all_data.dropna()
percentiles = valid['volatility'].quantile([0.2, 0.5, 0.8]).values

print(f"20th percentile (low volatility):  {percentiles[0]:.6f}")
print(f"50th percentile (medium):          {percentiles[1]:.6f}")
print(f"80th percentile (high volatility): {percentiles[2]:.6f}")
print()
print("Suggested thresholds:")
print(f"  VOLATILITY_LOW_THRESHOLD:  {percentiles[0]:.6f}")
print(f"  VOLATILITY_HIGH_THRESHOLD: {percentiles[2]:.6f}")
print()

```

## üìÑ **FILE 4 of 11**: include/strategy/market_regime_detector.h

**File Information**:
- **Path**: `include/strategy/market_regime_detector.h`

- **Size**: 60 lines
- **Modified**: 2025-10-08 19:47:07

- **Type**: .h

```text
#pragma once

#include "common/types.h"
#include <vector>
#include <cmath>

namespace sentio {

// Market regime types
enum class MarketRegime {
    TRENDING_UP,
    TRENDING_DOWN,
    CHOPPY,
    HIGH_VOLATILITY,
    LOW_VOLATILITY
};

// Indicators for regime classification
struct RegimeIndicators {
    double adx;           // Average Directional Index (trend strength)
    double atr;           // Average True Range (volatility)
    double slope;         // Price slope (trend direction)
    double chopiness;     // Chopiness Index
    double volatility;    // Normalized volatility

    RegimeIndicators()
        : adx(0.0), atr(0.0), slope(0.0), chopiness(0.0), volatility(0.0) {}
};

// Market regime detector
class MarketRegimeDetector {
public:
    MarketRegimeDetector(int lookback_period = 100);

    // Detect regime from recent bar history
    MarketRegime detect_regime(const std::vector<Bar>& recent_bars);

    // Calculate regime indicators
    RegimeIndicators calculate_indicators(const std::vector<Bar>& bars);

    // Get regime name as string
    static std::string regime_to_string(MarketRegime regime);

private:
    int lookback_period_;

    // Technical indicator calculations
    double calculate_adx(const std::vector<Bar>& bars, int period = 14);
    double calculate_atr(const std::vector<Bar>& bars, int period = 14);
    double calculate_sma(const std::vector<Bar>& bars, int period);
    double calculate_slope(const std::vector<Bar>& bars);
    double calculate_chopiness(const std::vector<Bar>& bars, int period = 14);

    // Helper functions
    double calculate_true_range(const Bar& current, const Bar& previous);
    std::vector<double> calculate_dm_plus_minus(const std::vector<Bar>& bars);
    double smooth_wilder(const std::vector<double>& values, int period);
};

} // namespace sentio

```

## üìÑ **FILE 5 of 11**: include/strategy/online_ensemble_strategy.h

**File Information**:
- **Path**: `include/strategy/online_ensemble_strategy.h`

- **Size**: 224 lines
- **Modified**: 2025-10-08 20:38:44

- **Type**: .h

```text
#pragma once

#include "strategy/strategy_component.h"
#include "strategy/signal_output.h"
#include "strategy/market_regime_detector.h"
#include "strategy/regime_parameter_manager.h"
#include "learning/online_predictor.h"
#include "features/unified_feature_engine.h"
#include "common/types.h"
#include <memory>
#include <deque>
#include <vector>
#include <map>

namespace sentio {

/**
 * @brief Full OnlineEnsemble Strategy using EWRLS multi-horizon predictor
 *
 * This strategy achieves online learning with ensemble methods:
 * - Real-time EWRLS model adaptation based on realized P&L
 * - Multi-horizon predictions (1, 5, 10 bars) with weighted ensemble
 * - Continuous performance tracking and adaptive calibration
 * - Target: 10% monthly return @ 60%+ signal accuracy
 *
 * Key Features:
 * - Incremental learning without retraining
 * - Adaptive learning rate based on market volatility
 * - Self-calibrating buy/sell thresholds
 * - Kelly Criterion position sizing integration
 * - Real-time performance metrics
 */
class OnlineEnsembleStrategy : public StrategyComponent {
public:
    struct OnlineEnsembleConfig : public StrategyConfig {
        // EWRLS parameters
        double ewrls_lambda = 0.995;          // Forgetting factor (0.99-0.999)
        double initial_variance = 100.0;       // Initial parameter uncertainty
        double regularization = 0.01;          // L2 regularization
        int warmup_samples = 100;              // Minimum samples before trading

        // Multi-horizon ensemble parameters
        std::vector<int> prediction_horizons = {1, 5, 10};  // Prediction horizons (bars)
        std::vector<double> horizon_weights = {0.3, 0.5, 0.2};  // Ensemble weights

        // Adaptive learning parameters
        bool enable_adaptive_learning = true;
        double min_lambda = 0.990;             // Fast adaptation limit
        double max_lambda = 0.999;             // Slow adaptation limit

        // Signal generation thresholds
        double buy_threshold = 0.53;           // Initial buy threshold
        double sell_threshold = 0.47;          // Initial sell threshold
        double neutral_zone = 0.06;            // Width of neutral zone

        // Bollinger Bands amplification (from WilliamsRSIBB strategy)
        bool enable_bb_amplification = true;   // Enable BB-based signal amplification
        int bb_period = 20;                    // BB period (matches feature engine)
        double bb_std_dev = 2.0;               // BB standard deviations
        double bb_proximity_threshold = 0.30;  // Within 30% of band for amplification
        double bb_amplification_factor = 0.10; // Boost probability by this much

        // Adaptive calibration
        bool enable_threshold_calibration = true;
        int calibration_window = 200;          // Bars for threshold calibration
        double target_win_rate = 0.60;        // Target 60% accuracy
        double threshold_step = 0.005;         // Calibration step size

        // Risk management
        bool enable_kelly_sizing = true;
        double kelly_fraction = 0.25;          // 25% of full Kelly
        double max_position_size = 0.50;       // Max 50% capital per position

        // Performance tracking
        int performance_window = 200;          // Window for metrics
        double target_monthly_return = 0.10;   // Target 10% monthly return

        // Regime detection parameters
        bool enable_regime_detection = false;  // Enable regime-aware parameter switching
        int regime_check_interval = 100;       // Check regime every N bars
        int regime_lookback_period = 100;      // Bars to analyze for regime detection

        OnlineEnsembleConfig() {
            name = "OnlineEnsemble";
            version = "2.0";
        }
    };

    struct PerformanceMetrics {
        double win_rate = 0.0;
        double avg_return = 0.0;
        double monthly_return_estimate = 0.0;
        double sharpe_estimate = 0.0;
        double directional_accuracy = 0.0;
        double recent_rmse = 0.0;
        int total_trades = 0;
        bool targets_met = false;
    };

    explicit OnlineEnsembleStrategy(const OnlineEnsembleConfig& config);
    virtual ~OnlineEnsembleStrategy() = default;

    // Main interface
    SignalOutput generate_signal(const Bar& bar);
    void update(const Bar& bar, double realized_pnl);
    void on_bar(const Bar& bar);

    // Predictor training (for warmup)
    void train_predictor(const std::vector<double>& features, double realized_return);
    std::vector<double> extract_features(const Bar& current_bar);

    // Feature caching support (for Optuna optimization speedup)
    void set_external_features(const std::vector<double>* features) {
        external_features_ = features;
        skip_feature_engine_update_ = (features != nullptr);
    }

    // Learning state management
    struct LearningState {
        int64_t last_trained_bar_id = -1;      // Global bar ID of last training
        int last_trained_bar_index = -1;       // Index of last trained bar
        int64_t last_trained_timestamp_ms = 0; // Timestamp of last training
        bool is_warmed_up = false;              // Feature engine ready
        bool is_learning_current = true;        // Learning is up-to-date
        int bars_behind = 0;                    // How many bars behind
    };

    LearningState get_learning_state() const { return learning_state_; }
    bool ensure_learning_current(const Bar& bar);  // Catch up if needed
    bool is_learning_current() const { return learning_state_.is_learning_current; }

    // Performance and diagnostics
    PerformanceMetrics get_performance_metrics() const;
    std::vector<double> get_feature_importance() const;
    bool is_ready() const { return samples_seen_ >= config_.warmup_samples; }

    // State persistence
    bool save_state(const std::string& path) const;
    bool load_state(const std::string& path);

private:
    OnlineEnsembleConfig config_;

    // Multi-horizon EWRLS predictor
    std::unique_ptr<learning::MultiHorizonPredictor> ensemble_predictor_;

    // Feature engineering (production-grade with O(1) updates, 45 features)
    std::unique_ptr<features::UnifiedFeatureEngine> feature_engine_;

    // Bar history for feature generation
    std::deque<Bar> bar_history_;
    static constexpr size_t MAX_HISTORY = 500;

    // Horizon tracking for delayed updates
    struct HorizonPrediction {
        int entry_bar_index;
        int target_bar_index;
        int horizon;
        std::shared_ptr<const std::vector<double>> features;  // Shared, immutable
        double entry_price;
        bool is_long;
    };

    struct PendingUpdate {
        std::array<HorizonPrediction, 3> horizons;  // Fixed size for 3 horizons
        uint8_t count = 0;  // Track actual count (1-3)
    };

    std::map<int, PendingUpdate> pending_updates_;

    // Performance tracking
    struct TradeResult {
        bool won;
        double return_pct;
        int64_t timestamp;
    };
    std::deque<TradeResult> recent_trades_;
    int samples_seen_;

    // Adaptive thresholds
    double current_buy_threshold_;
    double current_sell_threshold_;
    int calibration_count_;

    // Learning state tracking
    LearningState learning_state_;
    std::deque<Bar> missed_bars_;  // Queue of bars that need training

    // External feature support for caching
    const std::vector<double>* external_features_ = nullptr;
    bool skip_feature_engine_update_ = false;

    // Regime detection (optional)
    std::unique_ptr<MarketRegimeDetector> regime_detector_;
    std::unique_ptr<RegimeParameterManager> regime_param_manager_;
    MarketRegime current_regime_;
    int bars_since_regime_check_;

    // Private methods
    void calibrate_thresholds();
    void track_prediction(int bar_index, int horizon, const std::vector<double>& features,
                         double entry_price, bool is_long);
    void process_pending_updates(const Bar& current_bar);
    SignalType determine_signal(double probability) const;
    void update_performance_metrics(bool won, double return_pct);
    void check_and_update_regime();  // Regime detection method

    // BB amplification
    struct BollingerBands {
        double upper;
        double middle;
        double lower;
        double bandwidth;
        double position_pct;  // 0=lower band, 1=upper band
    };
    BollingerBands calculate_bollinger_bands() const;
    double apply_bb_amplification(double base_probability, const BollingerBands& bb) const;

    // Constants
    static constexpr int MIN_FEATURES_BARS = 100;  // Minimum bars for features
    static constexpr size_t TRADE_HISTORY_SIZE = 500;
};

} // namespace sentio

```

## üìÑ **FILE 6 of 11**: include/strategy/regime_parameter_manager.h

**File Information**:
- **Path**: `include/strategy/regime_parameter_manager.h`

- **Size**: 103 lines
- **Modified**: 2025-10-08 20:42:43

- **Type**: .h

```text
#pragma once

#include "strategy/market_regime_detector.h"
#include <map>
#include <string>

namespace sentio {

// Forward declaration to avoid circular dependency
class OnlineEnsembleStrategy;

// Parameter set for a specific market regime
struct RegimeParams {
    // Primary strategy parameters
    double buy_threshold;
    double sell_threshold;
    double ewrls_lambda;
    double bb_amplification_factor;

    // Secondary parameters
    double h1_weight;
    double h5_weight;
    double h10_weight;
    double bb_period;
    double bb_std_dev;
    double bb_proximity;
    double regularization;

    RegimeParams()
        : buy_threshold(0.53),
          sell_threshold(0.48),
          ewrls_lambda(0.992),
          bb_amplification_factor(0.05),
          h1_weight(0.20),
          h5_weight(0.50),
          h10_weight(0.30),
          bb_period(20),
          bb_std_dev(2.0),
          bb_proximity(0.30),
          regularization(0.01) {}

    RegimeParams(double buy, double sell, double lambda, double bb_amp,
                 double h1, double h5, double h10,
                 double bb_per, double bb_std, double bb_prox, double reg)
        : buy_threshold(buy),
          sell_threshold(sell),
          ewrls_lambda(lambda),
          bb_amplification_factor(bb_amp),
          h1_weight(h1),
          h5_weight(h5),
          h10_weight(h10),
          bb_period(bb_per),
          bb_std_dev(bb_std),
          bb_proximity(bb_prox),
          regularization(reg) {}

    // Validate parameters
    bool is_valid() const {
        if (buy_threshold <= sell_threshold) return false;
        if (buy_threshold < 0.5 || buy_threshold > 0.7) return false;
        if (sell_threshold < 0.3 || sell_threshold > 0.5) return false;
        if (ewrls_lambda < 0.98 || ewrls_lambda > 1.0) return false;
        if (bb_amplification_factor < 0.0 || bb_amplification_factor > 0.3) return false;

        double weight_sum = h1_weight + h5_weight + h10_weight;
        if (std::abs(weight_sum - 1.0) > 0.01) return false;

        return true;
    }
};

// Manage regime-specific parameters
class RegimeParameterManager {
public:
    RegimeParameterManager();

    // Get parameters for a specific regime
    RegimeParams get_params_for_regime(MarketRegime regime) const;

    // Set parameters for a specific regime
    void set_params_for_regime(MarketRegime regime, const RegimeParams& params);

    // Load default parameter sets (optimized for each regime)
    void load_default_params();

    // Load from config file
    bool load_from_file(const std::string& config_path);

    // Save to config file
    bool save_to_file(const std::string& config_path) const;

private:
    std::map<MarketRegime, RegimeParams> regime_params_;

    // Default parameter sets for each regime (from Optuna optimization)
    void init_trending_up_params();
    void init_trending_down_params();
    void init_choppy_params();
    void init_high_volatility_params();
    void init_low_volatility_params();
};

} // namespace sentio

```

## üìÑ **FILE 7 of 11**: scripts/generate_regime_test_data_mars.py

**File Information**:
- **Path**: `scripts/generate_regime_test_data_mars.py`

- **Size**: 212 lines
- **Modified**: 2025-10-08 21:40:30

- **Type**: .py

```text
#!/usr/bin/env python3
"""
Generate Multi-Regime SPY Test Data using MarS

Uses Microsoft Research's MarS (Market Simulation) to generate realistic
market data with controlled regimes for validating MarketRegimeDetector.
"""

import sys
import os
import pandas as pd
import numpy as np
from pathlib import Path
from datetime import datetime, timedelta
from pandas import Timestamp

# Add MarS to path
mars_path = Path(__file__).parent.parent / "quote_simulation" / "MarS"
sys.path.insert(0, str(mars_path))

from market_simulation.agents.noise_agent import NoiseAgent
from market_simulation.states.trade_info_state import TradeInfoState
from mlib.core.env import Env
from mlib.core.event import create_exchange_events
from mlib.core.exchange import Exchange
from mlib.core.exchange_config import create_exchange_config_without_call_auction

print("=" * 80)
print("MULTI-REGIME SPY TEST DATA GENERATOR (MarS-Powered)")
print("=" * 80)
print()

# Configuration
BASE_PRICE = 450.0
BARS_PER_BLOCK = 480  # 1 trading day
BLOCKS_PER_REGIME = 2  # 2 blocks per regime
SYMBOL = "SPY"

# Regime configurations (MarS parameters)
REGIMES = [
    ("TRENDING_UP", {"interval_seconds": 60, "seed": 100}),
    ("TRENDING_DOWN", {"interval_seconds": 60, "seed": 200}),
    ("CHOPPY", {"interval_seconds": 60, "seed": 300}),
    ("HIGH_VOLATILITY", {"interval_seconds": 60, "seed": 400}),
    ("LOW_VOLATILITY", {"interval_seconds": 60, "seed": 500}),
]

all_data = []
current_timestamp = Timestamp("2024-01-01 09:30:00")

print(f"Generating {len(REGIMES)} regimes √ó {BLOCKS_PER_REGIME} blocks √ó {BARS_PER_BLOCK} bars/block")
print(f"Total bars: {len(REGIMES) * BLOCKS_PER_REGIME * BARS_PER_BLOCK}")
print()

for regime_name, regime_config in REGIMES:
    print(f"Generating {regime_name} regime...")
    duration_minutes = BLOCKS_PER_REGIME * BARS_PER_BLOCK

    start_time = current_timestamp
    end_time = current_timestamp + timedelta(minutes=duration_minutes)

    # Create exchange environment
    exchange_config = create_exchange_config_without_call_auction(
        market_open=start_time,
        market_close=end_time,
        symbols=[SYMBOL],
    )
    exchange = Exchange(exchange_config)

    # Create noise agent with regime-specific seed
    agent = NoiseAgent(
        symbol=SYMBOL,
        init_price=int(BASE_PRICE * 100),  # MarS uses integer prices
        interval_seconds=regime_config["interval_seconds"],
        start_time=start_time,
        end_time=end_time,
        seed=regime_config["seed"],
    )

    # Setup simulation
    exchange.register_state(TradeInfoState())
    env = Env(exchange=exchange, description=f"MarS {regime_name}")
    env.register_agent(agent)
    env.push_events(create_exchange_events(exchange_config))

    # Run simulation
    for observation in env.env():
        action = observation.agent.get_action(observation)
        env.step(action)

    # Extract trade information
    state = exchange.states()[SYMBOL][TradeInfoState.__name__]
    trade_infos = state.trade_infos
    trade_infos = [x for x in trade_infos if start_time <= x.order.time <= end_time]

    # Convert to bars
    bars = []
    timestamp = start_time
    bar_interval = timedelta(minutes=1)

    for i in range(duration_minutes):
        # Find trades in this minute
        bar_start = timestamp
        bar_end = timestamp + bar_interval

        bar_trades = [t for t in trade_infos
                     if bar_start <= t.order.time < bar_end]

        if bar_trades:
            # Extract prices from trades
            prices = [t.lob_snapshot.last_price for t in bar_trades
                     if t.lob_snapshot.last_price > 0]
            volumes = [t.order.volume for t in bar_trades
                      if t.order.volume > 0]

            if prices:
                open_price = prices[0] / 100.0
                close_price = prices[-1] / 100.0
                high_price = max(prices) / 100.0
                low_price = min(prices) / 100.0
                volume = sum(volumes) if volumes else 100000
            else:
                # No valid prices, use previous close or base price
                prev_close = bars[-1]['close'] if bars else BASE_PRICE
                open_price = close_price = high_price = low_price = prev_close
                volume = 100000
        else:
            # No trades in this minute, use previous close
            prev_close = bars[-1]['close'] if bars else BASE_PRICE
            open_price = close_price = high_price = low_price = prev_close
            volume = 100000

        bars.append({
            'timestamp': timestamp,
            'open': open_price,
            'high': high_price,
            'low': low_price,
            'close': close_price,
            'volume': volume,
            'regime': regime_name,
        })

        timestamp += bar_interval

    all_data.extend(bars)
    current_timestamp = end_time

    start_price = bars[0]['close'] if bars else BASE_PRICE
    end_price = bars[-1]['close'] if bars else BASE_PRICE
    pct_change = ((end_price / start_price - 1) * 100) if start_price > 0 else 0

    print(f"  ‚úì Generated {len(bars)} bars, price: ${start_price:.2f} ‚Üí ${end_price:.2f} ({pct_change:+.1f}%)")

# Convert to DataFrame
df = pd.DataFrame(all_data)

# Save as CSV in sentio format
output_file = "data/equities/SPY_regime_test.csv"
print()
print(f"Saving to {output_file}...")

# Format timestamp as required
df['timestamp_ms'] = (df['timestamp'].astype(np.int64) // 1e6).astype(int)
df['date'] = df['timestamp'].dt.strftime('%Y-%m-%d')
df['time'] = df['timestamp'].dt.strftime('%H:%M:%S')

# Select and order columns
output_df = df[['timestamp_ms', 'date', 'time', 'open', 'high', 'low', 'close', 'volume']]

# Save without headers (sentio format)
output_df.to_csv(output_file, index=False, header=False)

# Also save with labels for validation
labeled_output = "data/tmp/spy_regime_test_labeled.csv"
df.to_csv(labeled_output, index=False)

print(f"‚úì Saved {len(df)} bars to {output_file}")
print(f"‚úì Saved labeled version to {labeled_output}")
print()

# Print summary
print("=" * 80)
print("GENERATION SUMMARY")
print("=" * 80)
print()
print(f"Total bars: {len(df)}")
print(f"Total blocks: {len(df) / BARS_PER_BLOCK:.1f}")
print()
print("Regime breakdown:")
for regime_name, _ in REGIMES:
    regime_data = df[df['regime'] == regime_name]
    blocks = len(regime_data) / BARS_PER_BLOCK
    print(f"  {regime_name:20s}: {len(regime_data):4d} bars ({blocks:.1f} blocks)")

print()
print("Price range:")
print(f"  Start: ${df['close'].iloc[0]:.2f}")
print(f"  End:   ${df['close'].iloc[-1]:.2f}")
print(f"  Min:   ${df['low'].min():.2f}")
print(f"  Max:   ${df['high'].max():.2f}")
print()

print("=" * 80)
print("NEXT STEPS")
print("=" * 80)
print()
print("1. Build regime test program:")
print("   cmake --build build --target test_regime_detector")
print()
print("2. Run regime validation:")
print("   ./build/test_regime_detector data/equities/SPY_regime_test.csv")
print()

```

## üìÑ **FILE 8 of 11**: src/strategy/market_regime_detector.cpp

**File Information**:
- **Path**: `src/strategy/market_regime_detector.cpp`

- **Size**: 252 lines
- **Modified**: 2025-10-08 21:46:05

- **Type**: .cpp

```text
#include "strategy/market_regime_detector.h"
#include <algorithm>
#include <numeric>
#include <stdexcept>

namespace sentio {

MarketRegimeDetector::MarketRegimeDetector(int lookback_period)
    : lookback_period_(lookback_period) {}

MarketRegime MarketRegimeDetector::detect_regime(const std::vector<Bar>& recent_bars) {
    if (recent_bars.size() < 50) {
        // Default to choppy if not enough data
        return MarketRegime::CHOPPY;
    }

    RegimeIndicators indicators = calculate_indicators(recent_bars);

    // Classification logic (thresholds calibrated for MarS NoiseAgent data)
    // MarS NoiseAgent analysis shows:
    //   ATR: $0.21-0.26, Price: ~$450, Volatility: 0.0005 (0.05%)
    //   20th percentile: 0.000310, 80th percentile: 0.000803
    const double ADX_TREND_THRESHOLD = 15.0;         // Lowered for MarS data
    const double VOLATILITY_HIGH_THRESHOLD = 0.00080;  // 80th percentile from MarS data
    const double VOLATILITY_LOW_THRESHOLD = 0.00031;   // 20th percentile from MarS data

    // High volatility regime (takes precedence)
    if (indicators.volatility > VOLATILITY_HIGH_THRESHOLD) {
        return MarketRegime::HIGH_VOLATILITY;
    }

    // Low volatility regime
    if (indicators.volatility < VOLATILITY_LOW_THRESHOLD) {
        return MarketRegime::LOW_VOLATILITY;
    }

    // Trending regimes
    if (indicators.adx > ADX_TREND_THRESHOLD) {
        if (indicators.slope > 0) {
            return MarketRegime::TRENDING_UP;
        } else {
            return MarketRegime::TRENDING_DOWN;
        }
    }

    // Default: choppy/sideways
    return MarketRegime::CHOPPY;
}

RegimeIndicators MarketRegimeDetector::calculate_indicators(const std::vector<Bar>& bars) {
    RegimeIndicators indicators;

    if (bars.size() < 30) {
        return indicators;  // Return zeros if insufficient data
    }

    // Take last N bars (up to lookback_period_)
    int n = std::min(static_cast<int>(bars.size()), lookback_period_);
    std::vector<Bar> recent(bars.end() - n, bars.end());

    indicators.adx = calculate_adx(recent, 14);
    indicators.atr = calculate_atr(recent, 14);
    indicators.slope = calculate_slope(recent);
    indicators.chopiness = calculate_chopiness(recent, 14);

    // Normalized volatility (ATR / price)
    if (recent.back().close > 0) {
        indicators.volatility = indicators.atr / recent.back().close;
    }

    return indicators;
}

std::string MarketRegimeDetector::regime_to_string(MarketRegime regime) {
    switch (regime) {
        case MarketRegime::TRENDING_UP: return "TRENDING_UP";
        case MarketRegime::TRENDING_DOWN: return "TRENDING_DOWN";
        case MarketRegime::CHOPPY: return "CHOPPY";
        case MarketRegime::HIGH_VOLATILITY: return "HIGH_VOLATILITY";
        case MarketRegime::LOW_VOLATILITY: return "LOW_VOLATILITY";
        default: return "UNKNOWN";
    }
}

// ADX Calculation (Average Directional Index)
double MarketRegimeDetector::calculate_adx(const std::vector<Bar>& bars, int period) {
    if (bars.size() < static_cast<size_t>(period + 1)) {
        return 0.0;
    }

    std::vector<double> tr_values;
    std::vector<double> dm_plus;
    std::vector<double> dm_minus;

    // Calculate True Range and Directional Movement
    for (size_t i = 1; i < bars.size(); ++i) {
        double tr = calculate_true_range(bars[i], bars[i-1]);
        tr_values.push_back(tr);

        double high_diff = bars[i].high - bars[i-1].high;
        double low_diff = bars[i-1].low - bars[i].low;

        double plus_dm = (high_diff > low_diff && high_diff > 0) ? high_diff : 0.0;
        double minus_dm = (low_diff > high_diff && low_diff > 0) ? low_diff : 0.0;

        dm_plus.push_back(plus_dm);
        dm_minus.push_back(minus_dm);
    }

    // Smooth with Wilder's method
    double smoothed_tr = smooth_wilder(tr_values, period);
    double smoothed_plus = smooth_wilder(dm_plus, period);
    double smoothed_minus = smooth_wilder(dm_minus, period);

    if (smoothed_tr == 0.0) {
        return 0.0;
    }

    // Calculate Directional Indicators
    double di_plus = 100.0 * smoothed_plus / smoothed_tr;
    double di_minus = 100.0 * smoothed_minus / smoothed_tr;

    // Calculate DX
    double di_diff = std::abs(di_plus - di_minus);
    double di_sum = di_plus + di_minus;

    if (di_sum == 0.0) {
        return 0.0;
    }

    double dx = 100.0 * di_diff / di_sum;

    return dx;  // Simplified: return DX (not smoothed ADX for speed)
}

// ATR Calculation (Average True Range)
double MarketRegimeDetector::calculate_atr(const std::vector<Bar>& bars, int period) {
    if (bars.size() < static_cast<size_t>(period + 1)) {
        return 0.0;
    }

    std::vector<double> tr_values;
    for (size_t i = 1; i < bars.size(); ++i) {
        tr_values.push_back(calculate_true_range(bars[i], bars[i-1]));
    }

    return smooth_wilder(tr_values, period);
}

// Simple Moving Average
double MarketRegimeDetector::calculate_sma(const std::vector<Bar>& bars, int period) {
    if (bars.size() < static_cast<size_t>(period)) {
        return 0.0;
    }

    double sum = 0.0;
    for (int i = bars.size() - period; i < static_cast<int>(bars.size()); ++i) {
        sum += bars[i].close;
    }

    return sum / period;
}

// Price slope (linear regression)
double MarketRegimeDetector::calculate_slope(const std::vector<Bar>& bars) {
    if (bars.size() < 2) {
        return 0.0;
    }

    int n = std::min(static_cast<int>(bars.size()), 50);  // Use last 50 bars
    std::vector<Bar> recent(bars.end() - n, bars.end());

    double sum_x = 0.0, sum_y = 0.0, sum_xy = 0.0, sum_x2 = 0.0;

    for (int i = 0; i < n; ++i) {
        double x = static_cast<double>(i);
        double y = recent[i].close;
        sum_x += x;
        sum_y += y;
        sum_xy += x * y;
        sum_x2 += x * x;
    }

    double slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);
    return slope;
}

// Chopiness Index
double MarketRegimeDetector::calculate_chopiness(const std::vector<Bar>& bars, int period) {
    if (bars.size() < static_cast<size_t>(period + 1)) {
        return 50.0;  // Neutral value
    }

    std::vector<Bar> recent(bars.end() - period, bars.end());

    // Calculate ATR sum
    double atr_sum = 0.0;
    for (size_t i = 1; i < recent.size(); ++i) {
        atr_sum += calculate_true_range(recent[i], recent[i-1]);
    }

    // Calculate high-low range
    double high_max = recent[0].high;
    double low_min = recent[0].low;
    for (const auto& bar : recent) {
        high_max = std::max(high_max, bar.high);
        low_min = std::min(low_min, bar.low);
    }

    double range = high_max - low_min;

    if (range == 0.0 || atr_sum == 0.0) {
        return 50.0;
    }

    // Chopiness formula
    double chop = 100.0 * std::log10(atr_sum / range) / std::log10(static_cast<double>(period));

    return chop;
}

// True Range
double MarketRegimeDetector::calculate_true_range(const Bar& current, const Bar& previous) {
    double h_l = current.high - current.low;
    double h_pc = std::abs(current.high - previous.close);
    double l_pc = std::abs(current.low - previous.close);

    return std::max({h_l, h_pc, l_pc});
}

// Wilder's smoothing
double MarketRegimeDetector::smooth_wilder(const std::vector<double>& values, int period) {
    if (values.size() < static_cast<size_t>(period)) {
        return 0.0;
    }

    // Initial SMA
    double sum = 0.0;
    for (int i = 0; i < period; ++i) {
        sum += values[i];
    }
    double smoothed = sum / period;

    // Wilder's smoothing for remaining values
    for (size_t i = period; i < values.size(); ++i) {
        smoothed = (smoothed * (period - 1) + values[i]) / period;
    }

    return smoothed;
}

} // namespace sentio

```

## üìÑ **FILE 9 of 11**: src/strategy/online_ensemble_strategy.cpp

**File Information**:
- **Path**: `src/strategy/online_ensemble_strategy.cpp`

- **Size**: 719 lines
- **Modified**: 2025-10-08 20:41:51

- **Type**: .cpp

```text
#include "strategy/online_ensemble_strategy.h"
#include "common/utils.h"
#include <cmath>
#include <algorithm>
#include <numeric>
#include <iostream>

namespace sentio {

OnlineEnsembleStrategy::OnlineEnsembleStrategy(const OnlineEnsembleConfig& config)
    : StrategyComponent(config),
      config_(config),
      samples_seen_(0),
      current_buy_threshold_(config.buy_threshold),
      current_sell_threshold_(config.sell_threshold),
      calibration_count_(0),
      current_regime_(MarketRegime::CHOPPY),
      bars_since_regime_check_(0) {

    // Initialize feature engine V2 (production-grade with O(1) updates)
    features::EngineConfig engine_config;
    engine_config.momentum = true;
    engine_config.volatility = true;
    engine_config.volume = true;
    engine_config.normalize = true;
    feature_engine_ = std::make_unique<features::UnifiedFeatureEngine>(engine_config);

    // Get feature count from V2 engine schema
    size_t num_features = feature_engine_->names().size();
    ensemble_predictor_ = std::make_unique<learning::MultiHorizonPredictor>(num_features);

    // Add predictors for each horizon with reduced warmup
    // EWRLS predictor warmup should be much smaller than strategy warmup
    // because updates are delayed by horizon length
    learning::OnlinePredictor::Config predictor_config;
    predictor_config.warmup_samples = 50;  // Lower warmup for EWRLS
    predictor_config.lambda = config_.ewrls_lambda;
    predictor_config.initial_variance = config_.initial_variance;
    predictor_config.regularization = config_.regularization;
    predictor_config.adaptive_learning = config_.enable_adaptive_learning;
    predictor_config.min_lambda = config_.min_lambda;
    predictor_config.max_lambda = config_.max_lambda;

    for (size_t i = 0; i < config_.prediction_horizons.size(); ++i) {
        int horizon = config_.prediction_horizons[i];
        double weight = config_.horizon_weights[i];
        // Need to pass config to add_horizon - but API doesn't support it
        // Will need to modify MultiHorizonPredictor
        ensemble_predictor_->add_horizon(horizon, weight);
    }

    // Initialize regime detection if enabled
    if (config_.enable_regime_detection) {
        regime_detector_ = std::make_unique<MarketRegimeDetector>(config_.regime_lookback_period);
        regime_param_manager_ = std::make_unique<RegimeParameterManager>();
        utils::log_info("Regime detection enabled - check interval: " +
                       std::to_string(config_.regime_check_interval) + " bars, lookback: " +
                       std::to_string(config_.regime_lookback_period) + " bars");
    }

    utils::log_info("OnlineEnsembleStrategy initialized with " +
                   std::to_string(config_.prediction_horizons.size()) + " horizons, " +
                   std::to_string(num_features) + " features");
}

SignalOutput OnlineEnsembleStrategy::generate_signal(const Bar& bar) {
    // CRITICAL: Ensure learning is current before generating signal
    if (!ensure_learning_current(bar)) {
        throw std::runtime_error(
            "[OnlineEnsemble] FATAL: Cannot generate signal - learning state is not current. "
            "Bar ID: " + std::to_string(bar.bar_id) +
            ", Last trained: " + std::to_string(learning_state_.last_trained_bar_id) +
            ", Bars behind: " + std::to_string(learning_state_.bars_behind));
    }

    SignalOutput output;
    output.bar_id = bar.bar_id;
    output.timestamp_ms = bar.timestamp_ms;
    output.bar_index = samples_seen_;
    output.symbol = "UNKNOWN";  // Set by caller if needed
    output.strategy_name = config_.name;
    output.strategy_version = config_.version;

    // Wait for warmup
    if (!is_ready()) {
        output.signal_type = SignalType::NEUTRAL;
        output.probability = 0.5;
        return output;
    }

    // Check and update regime if enabled
    check_and_update_regime();

    // Extract features
    std::vector<double> features = extract_features(bar);
    if (features.empty()) {
        output.signal_type = SignalType::NEUTRAL;
        output.probability = 0.5;
        return output;
    }

    // Get ensemble prediction
    auto prediction = ensemble_predictor_->predict(features);

    // DEBUG: Log prediction
    static int signal_count = 0;
    signal_count++;
    if (signal_count <= 10) {
        std::cout << "[OES] generate_signal #" << signal_count
                  << ": predicted_return=" << prediction.predicted_return
                  << ", confidence=" << prediction.confidence
                  << std::endl;
    }

    // Convert predicted return to probability
    // Predicted return is in decimal (e.g., 0.01 = 1% return)
    // Map to probability: positive return -> prob > 0.5, negative -> prob < 0.5
    double base_prob = 0.5 + std::tanh(prediction.predicted_return * 50.0) * 0.4;
    base_prob = std::clamp(base_prob, 0.05, 0.95);  // Keep within reasonable bounds

    if (signal_count <= 10) {
        std::cout << "[OES]   ‚Üí base_prob=" << base_prob << std::endl;
    }

    // Apply Bollinger Bands amplification if enabled
    double prob = base_prob;
    if (config_.enable_bb_amplification) {
        BollingerBands bb = calculate_bollinger_bands();
        prob = apply_bb_amplification(base_prob, bb);

        // Store BB metadata
        output.metadata["bb_upper"] = std::to_string(bb.upper);
        output.metadata["bb_middle"] = std::to_string(bb.middle);
        output.metadata["bb_lower"] = std::to_string(bb.lower);
        output.metadata["bb_position"] = std::to_string(bb.position_pct);
        output.metadata["base_probability"] = std::to_string(base_prob);
    }

    output.probability = prob;
    output.signal_type = determine_signal(prob);

    // Track for multi-horizon updates (always, not just for non-neutral signals)
    // This allows the model to learn from all market data, not just when we trade
    bool is_long = (prob > 0.5);  // Use probability, not signal type
    for (int horizon : config_.prediction_horizons) {
        track_prediction(samples_seen_, horizon, features, bar.close, is_long);
    }

    // Add metadata
    output.metadata["confidence"] = std::to_string(prediction.confidence);
    output.metadata["volatility"] = std::to_string(prediction.volatility_estimate);
    output.metadata["buy_threshold"] = std::to_string(current_buy_threshold_);
    output.metadata["sell_threshold"] = std::to_string(current_sell_threshold_);

    return output;
}

void OnlineEnsembleStrategy::update(const Bar& bar, double realized_pnl) {
    // Update performance metrics
    if (std::abs(realized_pnl) > 1e-6) {  // Non-zero P&L
        double return_pct = realized_pnl / 100000.0;  // Assuming $100k base
        bool won = (realized_pnl > 0);
        update_performance_metrics(won, return_pct);
    }

    // Process pending horizon updates
    process_pending_updates(bar);
}

void OnlineEnsembleStrategy::on_bar(const Bar& bar) {
    // Add to history
    bar_history_.push_back(bar);
    if (bar_history_.size() > MAX_HISTORY) {
        bar_history_.pop_front();
    }

    // Update feature engine V2 (skip if using external cached features)
    if (!skip_feature_engine_update_) {
        feature_engine_->update(bar);
    }

    samples_seen_++;

    // Calibrate thresholds periodically
    if (config_.enable_threshold_calibration &&
        samples_seen_ % config_.calibration_window == 0 &&
        is_ready()) {
        calibrate_thresholds();
    }

    // Process any pending updates for this bar
    process_pending_updates(bar);

    // Update learning state after processing this bar
    learning_state_.last_trained_bar_id = bar.bar_id;
    learning_state_.last_trained_bar_index = samples_seen_ - 1;  // 0-indexed
    learning_state_.last_trained_timestamp_ms = bar.timestamp_ms;
    learning_state_.is_warmed_up = (samples_seen_ >= config_.warmup_samples);
    learning_state_.is_learning_current = true;
    learning_state_.bars_behind = 0;
}

std::vector<double> OnlineEnsembleStrategy::extract_features(const Bar& current_bar) {
    // Use external features if provided (for feature caching optimization)
    if (external_features_ != nullptr) {
        return *external_features_;
    }

    // DEBUG: Track why features might be empty
    static int extract_count = 0;
    extract_count++;

    if (bar_history_.size() < MIN_FEATURES_BARS) {
        if (extract_count <= 10) {
            std::cout << "[OES] extract_features #" << extract_count
                      << ": bar_history_.size()=" << bar_history_.size()
                      << " < MIN_FEATURES_BARS=" << MIN_FEATURES_BARS
                      << " ‚Üí returning empty"
                      << std::endl;
        }
        return {};  // Not enough history
    }

    // UnifiedFeatureEngine maintains its own history via update()
    // Just get the current features after the bar has been added to history
    if (!feature_engine_->is_seeded()) {
        if (extract_count <= 10) {
            std::cout << "[OES] extract_features #" << extract_count
                      << ": feature_engine_v2 NOT ready ‚Üí returning empty"
                      << std::endl;
        }
        return {};
    }

    // Get features from V2 engine (returns const vector& - no copy)
    const auto& features_view = feature_engine_->features_view();
    std::vector<double> features(features_view.begin(), features_view.end());
    if (extract_count <= 10 || features.empty()) {
        std::cout << "[OES] extract_features #" << extract_count
                  << ": got " << features.size() << " features from engine"
                  << std::endl;
    }

    return features;
}

void OnlineEnsembleStrategy::train_predictor(const std::vector<double>& features, double realized_return) {
    if (features.empty()) {
        return;  // Nothing to train on
    }

    // Train all horizon predictors with the same realized return
    // (In practice, each horizon would use its own future return, but for warmup we use next-bar return)
    for (int horizon : config_.prediction_horizons) {
        ensemble_predictor_->update(horizon, features, realized_return);
    }
}

void OnlineEnsembleStrategy::track_prediction(int bar_index, int horizon,
                                              const std::vector<double>& features,
                                              double entry_price, bool is_long) {
    // Create shared_ptr only once per bar (reuse for all horizons)
    static std::shared_ptr<const std::vector<double>> shared_features;
    static int last_bar_index = -1;

    if (bar_index != last_bar_index) {
        // New bar - create new shared features
        shared_features = std::make_shared<const std::vector<double>>(features);
        last_bar_index = bar_index;
    }

    HorizonPrediction pred;
    pred.entry_bar_index = bar_index;
    pred.target_bar_index = bar_index + horizon;
    pred.horizon = horizon;
    pred.features = shared_features;  // Share, don't copy
    pred.entry_price = entry_price;
    pred.is_long = is_long;

    // Use fixed array instead of vector
    auto& update = pending_updates_[pred.target_bar_index];
    if (update.count < 3) {
        update.horizons[update.count++] = std::move(pred);  // Move, don't copy
    }
}

void OnlineEnsembleStrategy::process_pending_updates(const Bar& current_bar) {
    auto it = pending_updates_.find(samples_seen_);
    if (it != pending_updates_.end()) {
        const auto& update = it->second;

        // Process only the valid predictions (0 to count-1)
        for (uint8_t i = 0; i < update.count; ++i) {
            const auto& pred = update.horizons[i];

            double actual_return = (current_bar.close - pred.entry_price) / pred.entry_price;
            if (!pred.is_long) {
                actual_return = -actual_return;
            }

            // Dereference shared_ptr only when needed
            ensemble_predictor_->update(pred.horizon, *pred.features, actual_return);
        }

        if (samples_seen_ % 100 == 0) {
            utils::log_debug("Processed " + std::to_string(static_cast<int>(update.count)) +
                           " updates at bar " + std::to_string(samples_seen_) +
                           ", pending_count=" + std::to_string(pending_updates_.size()));
        }

        pending_updates_.erase(it);
    }
}

SignalType OnlineEnsembleStrategy::determine_signal(double probability) const {
    if (probability > current_buy_threshold_) {
        return SignalType::LONG;
    } else if (probability < current_sell_threshold_) {
        return SignalType::SHORT;
    } else {
        return SignalType::NEUTRAL;
    }
}

void OnlineEnsembleStrategy::update_performance_metrics(bool won, double return_pct) {
    TradeResult result;
    result.won = won;
    result.return_pct = return_pct;
    result.timestamp = 0;  // Could add actual timestamp

    recent_trades_.push_back(result);
    if (recent_trades_.size() > TRADE_HISTORY_SIZE) {
        recent_trades_.pop_front();
    }
}

void OnlineEnsembleStrategy::calibrate_thresholds() {
    if (recent_trades_.size() < 50) {
        return;  // Not enough data
    }

    // Calculate current win rate
    int wins = std::count_if(recent_trades_.begin(), recent_trades_.end(),
                            [](const TradeResult& r) { return r.won; });
    double win_rate = static_cast<double>(wins) / recent_trades_.size();

    // Adjust thresholds to hit target win rate
    if (win_rate < config_.target_win_rate) {
        // Win rate too low -> make thresholds more selective (move apart)
        current_buy_threshold_ += config_.threshold_step;
        current_sell_threshold_ -= config_.threshold_step;
    } else if (win_rate > config_.target_win_rate + 0.05) {
        // Win rate too high -> trade more (move together)
        current_buy_threshold_ -= config_.threshold_step;
        current_sell_threshold_ += config_.threshold_step;
    }

    // Keep within reasonable bounds
    current_buy_threshold_ = std::clamp(current_buy_threshold_, 0.51, 0.70);
    current_sell_threshold_ = std::clamp(current_sell_threshold_, 0.30, 0.49);

    // Ensure minimum separation
    double min_separation = 0.04;
    if (current_buy_threshold_ - current_sell_threshold_ < min_separation) {
        double center = (current_buy_threshold_ + current_sell_threshold_) / 2.0;
        current_buy_threshold_ = center + min_separation / 2.0;
        current_sell_threshold_ = center - min_separation / 2.0;
    }

    calibration_count_++;
    utils::log_info("Calibrated thresholds #" + std::to_string(calibration_count_) +
                   ": buy=" + std::to_string(current_buy_threshold_) +
                   ", sell=" + std::to_string(current_sell_threshold_) +
                   " (win_rate=" + std::to_string(win_rate) + ")");
}

OnlineEnsembleStrategy::PerformanceMetrics
OnlineEnsembleStrategy::get_performance_metrics() const {
    PerformanceMetrics metrics;

    if (recent_trades_.empty()) {
        return metrics;
    }

    // Win rate
    int wins = std::count_if(recent_trades_.begin(), recent_trades_.end(),
                            [](const TradeResult& r) { return r.won; });
    metrics.win_rate = static_cast<double>(wins) / recent_trades_.size();
    metrics.total_trades = static_cast<int>(recent_trades_.size());

    // Average return
    double sum_returns = std::accumulate(recent_trades_.begin(), recent_trades_.end(), 0.0,
                                        [](double sum, const TradeResult& r) {
                                            return sum + r.return_pct;
                                        });
    metrics.avg_return = sum_returns / recent_trades_.size();

    // Monthly return estimate (assuming 252 trading days, ~21 per month)
    // If we have N trades over M bars, estimate monthly trades
    if (samples_seen_ > 0) {
        double trades_per_bar = static_cast<double>(recent_trades_.size()) / std::min(samples_seen_, 500);
        double bars_per_month = 21.0 * 390.0;  // 21 days * 390 minutes (6.5 hours)
        double monthly_trades = trades_per_bar * bars_per_month;
        metrics.monthly_return_estimate = metrics.avg_return * monthly_trades;
    }

    // Sharpe estimate
    if (recent_trades_.size() > 10) {
        double mean = metrics.avg_return;
        double sum_sq = 0.0;
        for (const auto& trade : recent_trades_) {
            double diff = trade.return_pct - mean;
            sum_sq += diff * diff;
        }
        double std_dev = std::sqrt(sum_sq / recent_trades_.size());
        if (std_dev > 1e-8) {
            metrics.sharpe_estimate = mean / std_dev * std::sqrt(252.0);  // Annualized
        }
    }

    // Check if targets met
    metrics.targets_met = (metrics.win_rate >= config_.target_win_rate) &&
                         (metrics.monthly_return_estimate >= config_.target_monthly_return);

    return metrics;
}

std::vector<double> OnlineEnsembleStrategy::get_feature_importance() const {
    // Get feature importance from first predictor (they should be similar)
    // Would need to expose this through MultiHorizonPredictor
    // For now return empty
    return {};
}

bool OnlineEnsembleStrategy::save_state(const std::string& path) const {
    try {
        std::ofstream file(path, std::ios::binary);
        if (!file.is_open()) return false;

        // Save basic state
        file.write(reinterpret_cast<const char*>(&samples_seen_), sizeof(int));
        file.write(reinterpret_cast<const char*>(&current_buy_threshold_), sizeof(double));
        file.write(reinterpret_cast<const char*>(&current_sell_threshold_), sizeof(double));
        file.write(reinterpret_cast<const char*>(&calibration_count_), sizeof(int));

        // Save trade history size
        size_t trade_count = recent_trades_.size();
        file.write(reinterpret_cast<const char*>(&trade_count), sizeof(size_t));

        // Save trades
        for (const auto& trade : recent_trades_) {
            file.write(reinterpret_cast<const char*>(&trade.won), sizeof(bool));
            file.write(reinterpret_cast<const char*>(&trade.return_pct), sizeof(double));
            file.write(reinterpret_cast<const char*>(&trade.timestamp), sizeof(int64_t));
        }

        file.close();
        utils::log_info("Saved OnlineEnsembleStrategy state to: " + path);
        return true;

    } catch (const std::exception& e) {
        utils::log_error("Failed to save state: " + std::string(e.what()));
        return false;
    }
}

bool OnlineEnsembleStrategy::load_state(const std::string& path) {
    try {
        std::ifstream file(path, std::ios::binary);
        if (!file.is_open()) return false;

        // Load basic state
        file.read(reinterpret_cast<char*>(&samples_seen_), sizeof(int));
        file.read(reinterpret_cast<char*>(&current_buy_threshold_), sizeof(double));
        file.read(reinterpret_cast<char*>(&current_sell_threshold_), sizeof(double));
        file.read(reinterpret_cast<char*>(&calibration_count_), sizeof(int));

        // Load trade history
        size_t trade_count;
        file.read(reinterpret_cast<char*>(&trade_count), sizeof(size_t));

        recent_trades_.clear();
        for (size_t i = 0; i < trade_count; ++i) {
            TradeResult trade;
            file.read(reinterpret_cast<char*>(&trade.won), sizeof(bool));
            file.read(reinterpret_cast<char*>(&trade.return_pct), sizeof(double));
            file.read(reinterpret_cast<char*>(&trade.timestamp), sizeof(int64_t));
            recent_trades_.push_back(trade);
        }

        file.close();
        utils::log_info("Loaded OnlineEnsembleStrategy state from: " + path);
        return true;

    } catch (const std::exception& e) {
        utils::log_error("Failed to load state: " + std::string(e.what()));
        return false;
    }
}

// Bollinger Bands calculation
OnlineEnsembleStrategy::BollingerBands OnlineEnsembleStrategy::calculate_bollinger_bands() const {
    BollingerBands bb;
    bb.upper = 0.0;
    bb.middle = 0.0;
    bb.lower = 0.0;
    bb.bandwidth = 0.0;
    bb.position_pct = 0.5;

    if (bar_history_.size() < static_cast<size_t>(config_.bb_period)) {
        return bb;
    }

    // Calculate SMA (middle band)
    size_t start = bar_history_.size() - config_.bb_period;
    double sum = 0.0;
    for (size_t i = start; i < bar_history_.size(); i++) {
        sum += bar_history_[i].close;
    }
    bb.middle = sum / config_.bb_period;

    // Calculate standard deviation
    double variance = 0.0;
    for (size_t i = start; i < bar_history_.size(); i++) {
        double diff = bar_history_[i].close - bb.middle;
        variance += diff * diff;
    }
    double std_dev = std::sqrt(variance / config_.bb_period);

    // Calculate bands
    bb.upper = bb.middle + (config_.bb_std_dev * std_dev);
    bb.lower = bb.middle - (config_.bb_std_dev * std_dev);
    bb.bandwidth = bb.upper - bb.lower;

    // Calculate position within bands (0=lower, 1=upper)
    double current_price = bar_history_.back().close;
    if (bb.bandwidth > 1e-8) {
        bb.position_pct = (current_price - bb.lower) / bb.bandwidth;
        bb.position_pct = std::clamp(bb.position_pct, 0.0, 1.0);
    }

    return bb;
}

// Apply BB amplification to base probability
double OnlineEnsembleStrategy::apply_bb_amplification(double base_probability, const BollingerBands& bb) const {
    double amplified_prob = base_probability;

    // Only amplify if BB bands are valid
    if (bb.bandwidth < 1e-8) {
        return amplified_prob;
    }

    // LONG signals: amplify when near lower band (position < threshold)
    if (base_probability > 0.5) {
        if (bb.position_pct <= config_.bb_proximity_threshold) {
            // Near lower band - amplify LONG signal
            double proximity_factor = 1.0 - (bb.position_pct / config_.bb_proximity_threshold);
            double amplification = config_.bb_amplification_factor * proximity_factor;
            amplified_prob += amplification;

            // Extra boost for extreme oversold (position < 10%)
            if (bb.position_pct < 0.10) {
                amplified_prob += 0.05;
            }
        }
    }
    // SHORT signals: amplify when near upper band (position > 1 - threshold)
    else if (base_probability < 0.5) {
        if (bb.position_pct >= (1.0 - config_.bb_proximity_threshold)) {
            // Near upper band - amplify SHORT signal
            double proximity_factor = (bb.position_pct - (1.0 - config_.bb_proximity_threshold)) / config_.bb_proximity_threshold;
            double amplification = config_.bb_amplification_factor * proximity_factor;
            amplified_prob -= amplification;

            // Extra boost for extreme overbought (position > 90%)
            if (bb.position_pct > 0.90) {
                amplified_prob -= 0.05;
            }
        }
    }

    // Clamp to valid probability range
    amplified_prob = std::clamp(amplified_prob, 0.05, 0.95);

    return amplified_prob;
}

// ============================================================================
// Learning State Management - Ensures model is always current before signals
// ============================================================================

bool OnlineEnsembleStrategy::ensure_learning_current(const Bar& bar) {
    // Check if this is the first bar (initial state)
    if (learning_state_.last_trained_bar_id == -1) {
        // First bar - just update state, don't train yet
        learning_state_.last_trained_bar_id = bar.bar_id;
        learning_state_.last_trained_bar_index = samples_seen_;
        learning_state_.last_trained_timestamp_ms = bar.timestamp_ms;
        learning_state_.is_warmed_up = (samples_seen_ >= config_.warmup_samples);
        learning_state_.is_learning_current = true;
        learning_state_.bars_behind = 0;
        return true;
    }

    // Check if we're already current with this bar
    if (learning_state_.last_trained_bar_id == bar.bar_id) {
        return true;  // Already trained on this bar
    }

    // Calculate how many bars behind we are
    int64_t bars_behind = bar.bar_id - learning_state_.last_trained_bar_id;

    if (bars_behind < 0) {
        // Going backwards in time - this should only happen during replay/testing
        std::cerr << "‚ö†Ô∏è  [OnlineEnsemble] WARNING: Bar ID went backwards! "
                  << "Current: " << bar.bar_id
                  << ", Last trained: " << learning_state_.last_trained_bar_id
                  << " (replaying historical data)" << std::endl;

        // Reset learning state for replay
        learning_state_.last_trained_bar_id = bar.bar_id;
        learning_state_.last_trained_bar_index = samples_seen_;
        learning_state_.last_trained_timestamp_ms = bar.timestamp_ms;
        learning_state_.is_learning_current = true;
        learning_state_.bars_behind = 0;
        return true;
    }

    if (bars_behind == 0) {
        return true;  // Current bar
    }

    if (bars_behind == 1) {
        // Normal case: exactly 1 bar behind (typical sequential processing)
        learning_state_.is_learning_current = true;
        learning_state_.bars_behind = 0;
        return true;
    }

    // We're more than 1 bar behind - need to catch up
    learning_state_.bars_behind = static_cast<int>(bars_behind);
    learning_state_.is_learning_current = false;

    // Only warn if feature engine is warmed up
    // (during warmup, it's normal to skip bars)
    if (learning_state_.is_warmed_up) {
        std::cerr << "‚ö†Ô∏è  [OnlineEnsemble] WARNING: Learning engine is " << bars_behind << " bars behind!"
                  << std::endl;
        std::cerr << "    Current bar ID: " << bar.bar_id
                  << ", Last trained: " << learning_state_.last_trained_bar_id
                  << std::endl;
        std::cerr << "    This should only happen during warmup. Once warmed up, "
                  << "the system must stay fully updated." << std::endl;

        // In production live trading, this is FATAL
        // Cannot generate signals without being current
        return false;
    }

    // During warmup, it's OK to be behind
    // Mark as current and continue
    learning_state_.is_learning_current = true;
    learning_state_.bars_behind = 0;
    return true;
}

void OnlineEnsembleStrategy::check_and_update_regime() {
    if (!config_.enable_regime_detection || !regime_detector_) {
        return;
    }

    // Check regime periodically
    bars_since_regime_check_++;
    if (bars_since_regime_check_ < config_.regime_check_interval) {
        return;
    }

    bars_since_regime_check_ = 0;

    // Need sufficient history
    if (bar_history_.size() < static_cast<size_t>(config_.regime_lookback_period)) {
        return;
    }

    // Detect current regime
    std::vector<Bar> recent_bars(bar_history_.end() - config_.regime_lookback_period,
                                 bar_history_.end());
    MarketRegime new_regime = regime_detector_->detect_regime(recent_bars);

    // Switch parameters if regime changed
    if (new_regime != current_regime_) {
        MarketRegime old_regime = current_regime_;
        current_regime_ = new_regime;

        RegimeParams params = regime_param_manager_->get_params_for_regime(new_regime);

        // Apply new thresholds
        current_buy_threshold_ = params.buy_threshold;
        current_sell_threshold_ = params.sell_threshold;

        // Log regime transition
        utils::log_info("Regime transition: " +
                       MarketRegimeDetector::regime_to_string(old_regime) + " -> " +
                       MarketRegimeDetector::regime_to_string(new_regime) +
                       " | buy=" + std::to_string(current_buy_threshold_) +
                       " sell=" + std::to_string(current_sell_threshold_) +
                       " lambda=" + std::to_string(params.ewrls_lambda) +
                       " bb=" + std::to_string(params.bb_amplification_factor));

        // Note: For full regime switching, we would also update:
        // - config_.ewrls_lambda (requires rebuilding predictor)
        // - config_.bb_amplification_factor
        // - config_.horizon_weights
        // For now, only threshold switching is implemented (most impactful)
    }
}

} // namespace sentio

```

## üìÑ **FILE 10 of 11**: src/strategy/regime_parameter_manager.cpp

**File Information**:
- **Path**: `src/strategy/regime_parameter_manager.cpp`

- **Size**: 153 lines
- **Modified**: 2025-10-08 20:43:00

- **Type**: .cpp

```text
#include "strategy/regime_parameter_manager.h"
#include "strategy/online_ensemble_strategy.h"
#include <fstream>
#include <iostream>

namespace sentio {

RegimeParameterManager::RegimeParameterManager() {
    load_default_params();
}

RegimeParams RegimeParameterManager::get_params_for_regime(MarketRegime regime) const {
    auto it = regime_params_.find(regime);
    if (it != regime_params_.end()) {
        return it->second;
    }

    // Fallback to CHOPPY params if regime not found
    auto fallback = regime_params_.find(MarketRegime::CHOPPY);
    if (fallback != regime_params_.end()) {
        return fallback->second;
    }

    // Ultimate fallback: default constructor
    return RegimeParams();
}

void RegimeParameterManager::set_params_for_regime(MarketRegime regime, const RegimeParams& params) {
    if (params.is_valid()) {
        regime_params_[regime] = params;
    } else {
        std::cerr << "Warning: Invalid parameters for regime "
                  << MarketRegimeDetector::regime_to_string(regime) << std::endl;
    }
}

void RegimeParameterManager::load_default_params() {
    init_trending_up_params();
    init_trending_down_params();
    init_choppy_params();
    init_high_volatility_params();
    init_low_volatility_params();
}

// Default parameters for TRENDING_UP regime
// Optimized for capturing upward momentum
void RegimeParameterManager::init_trending_up_params() {
    RegimeParams params(
        0.55,   // buy_threshold (wide gap to capture trends)
        0.43,   // sell_threshold
        0.992,  // ewrls_lambda (moderate adaptation)
        0.08,   // bb_amplification_factor
        0.15,   // h1_weight (favor longer horizons in trends)
        0.60,   // h5_weight
        0.25,   // h10_weight
        20,     // bb_period
        2.25,   // bb_std_dev
        0.30,   // bb_proximity
        0.016   // regularization
    );
    regime_params_[MarketRegime::TRENDING_UP] = params;
}

// Default parameters for TRENDING_DOWN regime
// Similar to trending up but with slightly different thresholds
void RegimeParameterManager::init_trending_down_params() {
    RegimeParams params(
        0.56,   // buy_threshold (slightly higher to avoid catching falling knives)
        0.42,   // sell_threshold (more aggressive shorts)
        0.992,  // ewrls_lambda
        0.08,   // bb_amplification_factor
        0.15,   // h1_weight
        0.60,   // h5_weight
        0.25,   // h10_weight
        20,     // bb_period
        2.25,   // bb_std_dev
        0.30,   // bb_proximity
        0.016   // regularization
    );
    regime_params_[MarketRegime::TRENDING_DOWN] = params;
}

// Default parameters for CHOPPY regime
// Narrower thresholds to avoid whipsaws
void RegimeParameterManager::init_choppy_params() {
    RegimeParams params(
        0.57,   // buy_threshold (narrower gap to reduce trades)
        0.45,   // sell_threshold
        0.995,  // ewrls_lambda (slower adaptation in noise)
        0.05,   // bb_amplification_factor (less aggressive)
        0.20,   // h1_weight (favor shorter horizons in chop)
        0.50,   // h5_weight
        0.30,   // h10_weight
        25,     // bb_period (longer period for smoothing)
        2.5,    // bb_std_dev (wider bands)
        0.35,   // bb_proximity
        0.025   // regularization (higher to reduce overfitting)
    );
    regime_params_[MarketRegime::CHOPPY] = params;
}

// Default parameters for HIGH_VOLATILITY regime
// Wider thresholds and faster adaptation
void RegimeParameterManager::init_high_volatility_params() {
    RegimeParams params(
        0.58,   // buy_threshold (wider gap for volatile moves)
        0.40,   // sell_threshold
        0.990,  // ewrls_lambda (faster adaptation)
        0.12,   // bb_amplification_factor (more aggressive)
        0.25,   // h1_weight (favor short horizons in volatility)
        0.45,   // h5_weight
        0.30,   // h10_weight
        15,     // bb_period (shorter for responsiveness)
        2.0,    // bb_std_dev
        0.25,   // bb_proximity
        0.010   // regularization (lower to be more responsive)
    );
    regime_params_[MarketRegime::HIGH_VOLATILITY] = params;
}

// Default parameters for LOW_VOLATILITY regime
// Tighter thresholds, more conservative
void RegimeParameterManager::init_low_volatility_params() {
    RegimeParams params(
        0.54,   // buy_threshold (tighter gap for small moves)
        0.46,   // sell_threshold
        0.996,  // ewrls_lambda (very slow adaptation)
        0.04,   // bb_amplification_factor (conservative)
        0.20,   // h1_weight
        0.50,   // h5_weight
        0.30,   // h10_weight
        30,     // bb_period (longer for stable regime)
        2.5,    // bb_std_dev
        0.40,   // bb_proximity
        0.030   // regularization (higher for stability)
    );
    regime_params_[MarketRegime::LOW_VOLATILITY] = params;
}

bool RegimeParameterManager::load_from_file(const std::string& config_path) {
    // TODO: Implement JSON/YAML config file loading
    // For now, just use defaults
    std::cerr << "Config file loading not yet implemented: " << config_path << std::endl;
    return false;
}

bool RegimeParameterManager::save_to_file(const std::string& config_path) const {
    // TODO: Implement JSON/YAML config file saving
    std::cerr << "Config file saving not yet implemented: " << config_path << std::endl;
    return false;
}

} // namespace sentio

```

## üìÑ **FILE 11 of 11**: tests/test_regime_detector.cpp

**File Information**:
- **Path**: `tests/test_regime_detector.cpp`

- **Size**: 309 lines
- **Modified**: 2025-10-08 21:13:04

- **Type**: .cpp

```text
/**
 * @file test_regime_detector.cpp
 * @brief Test MarketRegimeDetector on synthetic multi-regime data
 *
 * This program tests the MarketRegimeDetector on synthetic data with known regimes.
 * It validates that the detector correctly identifies different market conditions.
 */

#include "strategy/market_regime_detector.h"
#include "common/types.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <iomanip>
#include <vector>
#include <string>

using namespace sentio;

// Simple CSV loader for test data (timestamp_ms,date,time,open,high,low,close,volume)
std::vector<Bar> load_csv_bars(const std::string& filepath) {
    std::vector<Bar> bars;
    std::ifstream file(filepath);

    if (!file.is_open()) {
        throw std::runtime_error("Cannot open file: " + filepath);
    }

    std::string line;
    int line_num = 0;

    while (std::getline(file, line)) {
        line_num++;
        if (line.empty()) continue;

        std::stringstream ss(line);
        std::vector<std::string> fields;
        std::string field;

        while (std::getline(ss, field, ',')) {
            fields.push_back(field);
        }

        if (fields.size() < 8) {
            std::cerr << "Warning: Line " << line_num << " has only " << fields.size() << " fields\n";
            continue;
        }

        try {
            Bar bar;
            bar.timestamp_ms = std::stoll(fields[0]);
            bar.open = std::stod(fields[3]);
            bar.high = std::stod(fields[4]);
            bar.low = std::stod(fields[5]);
            bar.close = std::stod(fields[6]);
            bar.volume = std::stod(fields[7]);
            bar.bar_id = line_num;

            bars.push_back(bar);
        } catch (const std::exception& e) {
            std::cerr << "Error parsing line " << line_num << ": " << e.what() << "\n";
            continue;
        }
    }

    return bars;
}

struct RegimeSegment {
    int start_idx;
    int end_idx;
    MarketRegime detected_regime;
    int bars_count;
};

void print_regime_summary(const std::vector<RegimeSegment>& segments) {
    std::cout << "\n" << std::string(80, '=') << "\n";
    std::cout << "REGIME DETECTION SUMMARY\n";
    std::cout << std::string(80, '=') << "\n\n";

    std::map<MarketRegime, int> regime_counts;
    std::map<MarketRegime, int> total_bars;

    for (const auto& seg : segments) {
        regime_counts[seg.detected_regime]++;
        total_bars[seg.detected_regime] += seg.bars_count;
    }

    std::cout << "Regime distribution:\n";
    for (const auto& [regime, count] : regime_counts) {
        std::string regime_str = MarketRegimeDetector::regime_to_string(regime);
        int bars = total_bars[regime];
        double pct = (bars * 100.0) / 4800.0;  // Total 4800 bars
        std::cout << "  " << std::left << std::setw(20) << regime_str
                  << ": " << std::setw(4) << count << " segments, "
                  << std::setw(5) << bars << " bars ("
                  << std::fixed << std::setprecision(1) << pct << "%)\n";
    }
    std::cout << "\n";
}

void test_regime_detector_on_segment(const std::vector<Bar>& bars,
                                     int start, int end,
                                     const std::string& expected_regime,
                                     MarketRegimeDetector& detector) {
    // Get segment
    std::vector<Bar> segment(bars.begin() + start, bars.begin() + end);

    // Detect regime
    MarketRegime detected = detector.detect_regime(segment);
    std::string detected_str = MarketRegimeDetector::regime_to_string(detected);

    // Get indicators for analysis
    auto indicators = detector.calculate_indicators(segment);

    // Print results
    std::cout << "Bars [" << start << "-" << end << "] "
              << "(" << (end - start) << " bars)\n";
    std::cout << "  Expected:  " << expected_regime << "\n";
    std::cout << "  Detected:  " << detected_str;

    // Check if correct
    bool correct = false;
    if (expected_regime == "TRENDING_UP" && detected == MarketRegime::TRENDING_UP) correct = true;
    if (expected_regime == "TRENDING_DOWN" && detected == MarketRegime::TRENDING_DOWN) correct = true;
    if (expected_regime == "CHOPPY" && detected == MarketRegime::CHOPPY) correct = true;
    if (expected_regime == "HIGH_VOLATILITY" && detected == MarketRegime::HIGH_VOLATILITY) correct = true;
    if (expected_regime == "LOW_VOLATILITY" && detected == MarketRegime::LOW_VOLATILITY) correct = true;

    std::cout << (correct ? " ‚úì" : " ‚úó") << "\n";

    // Print indicators
    std::cout << "  Indicators:\n";
    std::cout << "    ADX:         " << std::fixed << std::setprecision(2) << indicators.adx << "\n";
    std::cout << "    ATR:         " << indicators.atr << "\n";
    std::cout << "    Slope:       " << indicators.slope << "\n";
    std::cout << "    Chopiness:   " << indicators.chopiness << "\n";
    std::cout << "    Volatility:  " << indicators.volatility << "\n";
    std::cout << "\n";
}

int main(int argc, char** argv) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <csv_file>\n";
        std::cerr << "Example: " << argv[0] << " data/equities/SPY_regime_test.csv\n";
        return 1;
    }

    std::string data_file = argv[1];

    std::cout << std::string(80, '=') << "\n";
    std::cout << "REGIME DETECTOR VALIDATION TEST\n";
    std::cout << std::string(80, '=') << "\n\n";
    std::cout << "Data file: " << data_file << "\n\n";

    // Load data
    std::vector<Bar> bars;

    try {
        bars = load_csv_bars(data_file);
    } catch (const std::exception& e) {
        std::cerr << "Error loading data: " << e.what() << "\n";
        return 1;
    }

    std::cout << "Loaded " << bars.size() << " bars\n\n";

    // Create detector
    MarketRegimeDetector detector(100);  // 100-bar lookback

    // Expected regime segments (from generate_regime_test_data.py)
    // Each regime = 2 blocks = 960 bars
    const int BARS_PER_REGIME = 960;
    struct ExpectedRegime {
        std::string name;
        int start;
        int end;
    };

    std::vector<ExpectedRegime> expected_regimes = {
        {"TRENDING_UP",      0,    BARS_PER_REGIME},
        {"TRENDING_DOWN",    BARS_PER_REGIME,   2 * BARS_PER_REGIME},
        {"CHOPPY",           2 * BARS_PER_REGIME, 3 * BARS_PER_REGIME},
        {"HIGH_VOLATILITY",  3 * BARS_PER_REGIME, 4 * BARS_PER_REGIME},
        {"LOW_VOLATILITY",   4 * BARS_PER_REGIME, 5 * BARS_PER_REGIME}
    };

    std::cout << std::string(80, '=') << "\n";
    std::cout << "TESTING REGIME DETECTION\n";
    std::cout << std::string(80, '=') << "\n\n";

    int correct_detections = 0;
    int total_tests = 0;

    // Test each regime segment
    for (const auto& expected : expected_regimes) {
        if (expected.end > static_cast<int>(bars.size())) {
            std::cerr << "Warning: Not enough data for regime " << expected.name << "\n";
            continue;
        }

        std::cout << "Testing " << expected.name << " segment...\n";

        // Test at multiple points within the segment
        std::vector<int> test_points = {
            expected.start + 100,      // Near start
            (expected.start + expected.end) / 2,  // Middle
            expected.end - 100          // Near end
        };

        for (int test_point : test_points) {
            int start = std::max(0, test_point - 100);
            int end = std::min(static_cast<int>(bars.size()), test_point + 100);

            if (end - start < 100) continue;

            std::vector<Bar> segment(bars.begin() + start, bars.begin() + end);
            MarketRegime detected = detector.detect_regime(segment);
            std::string detected_str = MarketRegimeDetector::regime_to_string(detected);

            // Check correctness
            bool correct = false;
            if (expected.name == "TRENDING_UP" && detected == MarketRegime::TRENDING_UP) correct = true;
            if (expected.name == "TRENDING_DOWN" && detected == MarketRegime::TRENDING_DOWN) correct = true;
            if (expected.name == "CHOPPY" && detected == MarketRegime::CHOPPY) correct = true;
            if (expected.name == "HIGH_VOLATILITY" && detected == MarketRegime::HIGH_VOLATILITY) correct = true;
            if (expected.name == "LOW_VOLATILITY" && detected == MarketRegime::LOW_VOLATILITY) correct = true;

            std::cout << "  Bar " << test_point << ": " << detected_str;
            std::cout << (correct ? " ‚úì\n" : " ‚úó\n");

            if (correct) correct_detections++;
            total_tests++;
        }

        std::cout << "\n";
    }

    // Calculate accuracy
    double accuracy = (total_tests > 0) ? (100.0 * correct_detections / total_tests) : 0.0;

    std::cout << std::string(80, '=') << "\n";
    std::cout << "VALIDATION RESULTS\n";
    std::cout << std::string(80, '=') << "\n\n";
    std::cout << "Total tests:         " << total_tests << "\n";
    std::cout << "Correct detections:  " << correct_detections << "\n";
    std::cout << "Accuracy:            " << std::fixed << std::setprecision(1)
              << accuracy << "%\n\n";

    if (accuracy >= 80.0) {
        std::cout << "‚úÖ VALIDATION PASSED (accuracy >= 80%)\n";
    } else if (accuracy >= 60.0) {
        std::cout << "‚ö†Ô∏è  VALIDATION WARNING (60% <= accuracy < 80%)\n";
        std::cout << "   Detector works but may need tuning\n";
    } else {
        std::cout << "‚ùå VALIDATION FAILED (accuracy < 60%)\n";
        std::cout << "   Detector parameters need adjustment\n";
    }

    std::cout << "\n";

    // Continuous detection test
    std::cout << std::string(80, '=') << "\n";
    std::cout << "CONTINUOUS REGIME DETECTION\n";
    std::cout << std::string(80, '=') << "\n\n";
    std::cout << "Detecting regimes every 100 bars...\n\n";

    std::vector<RegimeSegment> segments;
    MarketRegime current_regime = MarketRegime::CHOPPY;
    int segment_start = 0;

    for (size_t i = 100; i < bars.size(); i += 100) {
        std::vector<Bar> window(bars.begin() + i - 100, bars.begin() + i);
        MarketRegime detected = detector.detect_regime(window);

        if (detected != current_regime || i == bars.size() - 1) {
            // Regime changed or end of data
            RegimeSegment seg;
            seg.start_idx = segment_start;
            seg.end_idx = i;
            seg.detected_regime = current_regime;
            seg.bars_count = i - segment_start;

            if (seg.bars_count > 0) {
                segments.push_back(seg);
            }

            if (detected != current_regime) {
                std::cout << "Bar " << std::setw(5) << i << ": "
                          << std::setw(20) << std::left
                          << MarketRegimeDetector::regime_to_string(current_regime)
                          << " ‚Üí "
                          << MarketRegimeDetector::regime_to_string(detected) << "\n";
            }

            current_regime = detected;
            segment_start = i;
        }
    }

    print_regime_summary(segments);

    std::cout << std::string(80, '=') << "\n";
    std::cout << "TEST COMPLETE\n";
    std::cout << std::string(80, '=') << "\n\n";

    return (accuracy >= 60.0) ? 0 : 1;
}

```

